import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import folium
from folium.plugins import HeatMap
from streamlit_folium import st_folium
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.patches import Polygon as MplPolygon
from matplotlib.collections import PatchCollection
from scipy.spatial import cKDTree
from scipy.interpolate import griddata
import pydeck as pdk
import geopandas as gpd
from shapely.geometry import Polygon, Point, shape
from shapely.ops import unary_union
import io
import base64
import tempfile
import os
import re
import json

# Default EC/pH class values for 5 crops - these will be user-modifiable and saved
CROP_DEFAULTS = {
    "Tomatoes": {
        "ec": [500.0, 1000.0, 2000.0, 3000.0],
        "ph": [6.0, 6.5, 7.0, 7.5],
        "ec_labels": ["Low", "Medium", "High", "Very High", "Extreme"],
        "ph_labels": ["Acidic", "Slightly Acidic", "Neutral", "Slightly Alkaline", "Alkaline"]
    },
    "Cucumber": {
        "ec": [400.0, 800.0, 1500.0, 2500.0],
        "ph": [5.5, 6.0, 6.5, 7.0],
        "ec_labels": ["Low", "Medium", "High", "Very High", "Extreme"],
        "ph_labels": ["Acidic", "Slightly Acidic", "Neutral", "Slightly Alkaline", "Alkaline"]
    },
    "Zucchini": {
        "ec": [450.0, 900.0, 1800.0, 2800.0],
        "ph": [6.0, 6.5, 7.0, 7.5],
        "ec_labels": ["Low", "Medium", "High", "Very High", "Extreme"],
        "ph_labels": ["Acidic", "Slightly Acidic", "Neutral", "Slightly Alkaline", "Alkaline"]
    },
    "Eggplant": {
        "ec": [500.0, 1000.0, 2000.0, 3000.0],
        "ph": [5.5, 6.0, 6.5, 7.0],
        "ec_labels": ["Low", "Medium", "High", "Very High", "Extreme"],
        "ph_labels": ["Acidic", "Slightly Acidic", "Neutral", "Slightly Alkaline", "Alkaline"]
    },
    "Pepper": {
        "ec": [400.0, 850.0, 1700.0, 2600.0],
        "ph": [6.0, 6.5, 7.0, 7.5],
        "ec_labels": ["Low", "Medium", "High", "Very High", "Extreme"],
        "ph_labels": ["Acidic", "Slightly Acidic", "Neutral", "Slightly Alkaline", "Alkaline"]
    }
}

DEFAULT_BORDER = {
"type": "FeatureCollection",
"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:OGC:1.3:CRS84" } },
"features": [
{ "type": "Feature", "properties": { "shapeName": "Qatar", "shapeISO": "QAT", "shapeID": "15585745B7344527881026", "shapeGroup": "QAT", "shapeType": "ADM0" }, "geometry": { "type": "MultiPolygon", "coordinates": [ [ [ [ 51.3512114, 24.639444199999957 ], [ 51.349105099999981, 24.64137920000001 ], [ 51.345153, 24.6379139 ], [ 51.344703899999978, 24.6283913 ], [ 51.341867, 24.620675800000033 ], [ 51.342275300000026, 24.6152696 ], [ 51.343963800000026, 24.615008399999979 ], [ 51.345393600000023, 24.6229844 ], [ 51.3493276, 24.620143899999988 ], [ 51.349477299999954, 24.623489799999984 ], [ 51.34598, 24.631477099999962 ], [ 51.351032899999971, 24.625802600000032 ], [ 51.3512114, 24.639444199999957 ] ] ], [ [ [ 51.5819469, 25.349991100000032 ], [ 51.572538599999959, 25.349621 ], [ 51.564441400000035, 25.341253699999985 ], [ 51.569731300000029, 25.343823499999981 ], [ 51.577660800000025, 25.342029599999968 ], [ 51.584439099999976, 25.338142499999957 ], [ 51.584060099999974, 25.3477954 ], [ 51.5819469, 25.349991100000032 ] ] ], [ [ [ 51.528889400000011, 25.377291499999973 ], [ 51.525359599999987, 25.378551699999971 ], [ 51.512577300000018, 25.3733275 ], [ 51.5197585, 25.373602099999978 ], [ 51.522114299999963, 25.368480499999965 ], [ 51.531873800000028, 25.364966900000038 ], [ 51.530658500000015, 25.3697595 ], [ 51.528137200000032, 25.3708576 ], [ 51.529973199999979, 25.37434460000004 ], [ 51.528889400000011, 25.377291499999973 ] ] ], [ [ [ 51.54036030000001, 25.375792400000016 ], [ 51.539442700000023, 25.37753309999998 ], [ 51.5457864, 25.383270100000018 ], [ 51.5435999, 25.383280800000016 ], [ 51.532352400000015, 25.374721 ], [ 51.5328535, 25.3713244 ], [ 51.534743699999986, 25.368482300000025 ], [ 51.536684399999977, 25.3683327 ], [ 51.536164400000025, 25.3664854 ], [ 51.537934600000035, 25.3659 ], [ 51.537991, 25.363984500000022 ], [ 51.541310600000031, 25.36578619999997 ], [ 51.53965, 25.369044700000018 ], [ 51.540526299999975, 25.371466 ], [ 51.544976599999956, 25.37300849999998 ], [ 51.547619300000036, 25.370935100000022 ], [ 51.54789920000001, 25.367765499999958 ], [ 51.542608500000043, 25.364925800000012 ], [ 51.543084100000044, 25.361491 ], [ 51.54863, 25.3628034 ], [ 51.553408200000014, 25.361626399999956 ], [ 51.5556203, 25.3644018 ], [ 51.554409700000015, 25.367868300000026 ], [ 51.557776799999985, 25.3694836 ], [ 51.56013, 25.3665186 ], [ 51.556520599999963, 25.363832 ], [ 51.556389699999968, 25.360969599999969 ], [ 51.563188799999956, 25.361001500000032 ], [ 51.5648886, 25.358851599999962 ], [ 51.563476100000017, 25.356982699999961 ], [ 51.5650421, 25.355947700000034 ], [ 51.566350900000025, 25.356583200000035 ], [ 51.568034200000035, 25.355211300000033 ], [ 51.571215, 25.35678219999998 ], [ 51.570467099999981, 25.35865180000004 ], [ 51.572233300000015, 25.358980699999986 ], [ 51.569787100000028, 25.359426700000029 ], [ 51.569860399999968, 25.361320100000015 ], [ 51.566282799999982, 25.36378969999998 ], [ 51.56639429999997, 25.367228400000016 ], [ 51.563908099999963, 25.370674500000042 ], [ 51.564819300000039, 25.371828499999957 ], [ 51.5609973, 25.376786600000031 ], [ 51.555546199999988, 25.3767831 ], [ 51.55363270000003, 25.37997389999996 ], [ 51.551887699999973, 25.380075899999962 ], [ 51.5522883, 25.3750912 ], [ 51.550196099999987, 25.3733125 ], [ 51.5470843, 25.375539499999963 ], [ 51.549836100000043, 25.379808 ], [ 51.549687099999971, 25.3811209 ], [ 51.549632, 25.37975230000001 ], [ 51.548373800000022, 25.38001909999997 ], [ 51.548616699999961, 25.381489699999968 ], [ 51.550089499999963, 25.381375400000014 ], [ 51.54899650000003, 25.381742 ], [ 51.543826199999984, 25.3798757 ], [ 51.541199800000015, 25.37745259999998 ], [ 51.541261400000046, 25.374639700000031 ], [ 51.54036030000001, 25.375792400000016 ] ] ], [ [ [ 51.251982199999965, 26.159029899999972 ], [ 51.239630199999986, 26.1560309 ], [ 51.233420900000034, 26.1450529 ], [ 51.2236156, 26.140122600000012 ], [ 51.2205058, 26.140013100000012 ], [ 51.215515899999964, 26.1446856 ], [ 51.208825800000021, 26.1403394 ], [ 51.209823599999979, 26.142862799999985 ], [ 51.208236899999967, 26.1422265 ], [ 51.208567399999957, 26.143440800000025 ], [ 51.210337300000027, 26.145471299999986 ], [ 51.2068364, 26.146679899999977 ], [ 51.206232400000026, 26.14406680000004 ], [ 51.204383900000025, 26.144752700000037 ], [ 51.205439200000036, 26.147169800000011 ], [ 51.204143799999969, 26.147653299999959 ], [ 51.202290600000019, 26.142516500000021 ], [ 51.200250399999966, 26.143256699999981 ], [ 51.202528199999961, 26.148705 ], [ 51.200029299999969, 26.143248500000013 ], [ 51.2022033, 26.142336200000024 ], [ 51.20124119999997, 26.140962499999961 ], [ 51.1910793, 26.1391328 ], [ 51.188684700000032, 26.140725900000014 ], [ 51.188885400000025, 26.146243500000018 ], [ 51.1873607, 26.1470762 ], [ 51.183950600000017, 26.1378446 ], [ 51.186417500000026, 26.135395200000019 ], [ 51.184170199999976, 26.130426799999981 ], [ 51.18150340000004, 26.128906400000037 ], [ 51.180620800000021, 26.130624800000021 ], [ 51.181044800000016, 26.127233700000016 ], [ 51.160864499999981, 26.115952099999959 ], [ 51.157957300000042, 26.1119412 ], [ 51.154743499999967, 26.105057 ], [ 51.156629200000026, 26.099578 ], [ 51.152769, 26.093744200000021 ], [ 51.1537563, 26.08948829999996 ], [ 51.147605700000021, 26.083325799999976 ], [ 51.1282555, 26.072019700000023 ], [ 51.1232681, 26.07050490000001 ], [ 51.118773, 26.071937 ], [ 51.117927900000012, 26.075178 ], [ 51.119054699999985, 26.075161800000032 ], [ 51.115884, 26.079511699999966 ], [ 51.111037899999964, 26.080845899999957 ], [ 51.107614200000015, 26.076473600000035 ], [ 51.096208800000021, 26.0681175 ], [ 51.09250550000003, 26.069278399999959 ], [ 51.092223, 26.072366799999966 ], [ 51.090513799999989, 26.07301070000004 ], [ 51.086524799999985, 26.073527900000023 ], [ 51.084244100000021, 26.072114300000035 ], [ 51.086243, 26.078032100000023 ], [ 51.0833936, 26.078291 ], [ 51.081252500000026, 26.073402699999967 ], [ 51.083243800000034, 26.068512 ], [ 51.079680900000021, 26.066455299999966 ], [ 51.079535200000045, 26.062337699999979 ], [ 51.077397199999986, 26.060022700000015 ], [ 51.068277, 26.055265899999988 ], [ 51.049755, 26.049226200000039 ], [ 51.049469600000016, 26.04793949999998 ], [ 51.043486300000026, 26.046397500000026 ], [ 51.042916100000014, 26.045110799999968 ], [ 51.0400669, 26.044467799999968 ], [ 51.039497599999962, 26.0456265 ], [ 51.033925299999957, 26.0436727 ], [ 51.040478500000027, 26.041139800000032 ], [ 51.042921600000021, 26.036591600000033 ], [ 51.042375300000032, 26.03083939999998 ], [ 51.03789, 26.020143 ], [ 51.0403782, 26.014451899999965 ], [ 51.037945499999971, 26.011765600000011 ], [ 51.035039, 26.0129698 ], [ 51.0362584, 26.007605200000036 ], [ 51.032053100000041, 25.989950399999969 ], [ 51.032751199999979, 25.988765299999969 ], [ 51.035268800000011, 25.98895270000002 ], [ 51.035560900000021, 25.987099399999977 ], [ 51.031808300000037, 25.984910499999966 ], [ 51.027741399999982, 25.9846845 ], [ 51.02460750000003, 25.98986559999997 ], [ 51.023920899999972, 25.9873894 ], [ 51.020963, 25.987576600000025 ], [ 51.024305199999972, 25.983079399999983 ], [ 51.023937099999984, 25.977863 ], [ 51.01879570000002, 25.9721863 ], [ 51.017537800000035, 25.973097099999961 ], [ 51.0186966, 25.972116700000022 ], [ 51.0152746, 25.96786580000002 ], [ 51.020364599999979, 25.971330199999962 ], [ 51.02103290000003, 25.9698526 ], [ 51.021037799999988, 25.971486 ], [ 51.021542800000027, 25.969950500000024 ], [ 51.022493299999979, 25.9710053 ], [ 51.022087399999968, 25.96882 ], [ 51.023795299999975, 25.969069300000033 ], [ 51.022904199999964, 25.968041199999966 ], [ 51.0098622, 25.963150100000018 ], [ 51.008153899999961, 25.960705800000014 ], [ 51.005591799999983, 25.9616062 ], [ 51.004737700000014, 25.9599339 ], [ 51.002602199999977, 25.961992900000016 ], [ 51.002460399999968, 25.964566300000044 ], [ 50.999898199999983, 25.964823700000025 ], [ 50.997905200000012, 25.967654600000042 ], [ 50.9976205, 25.969456099999974 ], [ 50.999898199999983, 25.971514899999967 ], [ 50.996196799999971, 25.976147099999988 ], [ 50.995912, 25.979492799999967 ], [ 50.999625299999963, 25.981901 ], [ 50.996194699999975, 25.98019870000002 ], [ 50.99249080000002, 25.983220400000015 ], [ 50.992881500000017, 25.984628900000025 ], [ 50.990502, 25.980521900000028 ], [ 50.9887935, 25.9818086 ], [ 50.988935800000043, 25.97743360000003 ], [ 50.98651620000004, 25.975374500000012 ], [ 50.98851, 25.9686835 ], [ 50.990075500000017, 25.968169 ], [ 50.988795, 25.965595400000016 ], [ 50.989791599999975, 25.958389600000039 ], [ 50.992781199999982, 25.957875 ], [ 50.993777199999968, 25.954272099999972 ], [ 50.9924969, 25.95247069999996 ], [ 50.9923542, 25.948610400000035 ], [ 50.994347, 25.945264899999984 ], [ 50.992924400000014, 25.935228 ], [ 50.996055600000012, 25.925963500000012 ], [ 50.994775300000036, 25.924419299999965 ], [ 50.996340400000037, 25.9190149 ], [ 50.993637500000041, 25.915669200000021 ], [ 50.992784, 25.911294 ], [ 50.994064099999989, 25.910007299999979 ], [ 50.992215100000038, 25.90717649999997 ], [ 50.991931099999988, 25.901514600000016 ], [ 50.988516800000014, 25.8994554 ], [ 50.987094400000011, 25.8963672 ], [ 50.982542300000041, 25.894178800000031 ], [ 50.97941239999998, 25.894307500000021 ], [ 50.978560099999982, 25.887101300000012 ], [ 50.975146299999963, 25.885556800000028 ], [ 50.974009100000018, 25.881696099999981 ], [ 50.971448900000013, 25.881181 ], [ 50.97287250000003, 25.8762914 ], [ 50.977424399999983, 25.875262899999981 ], [ 50.976572899999958, 25.864968399999974 ], [ 50.970599399999983, 25.8647101 ], [ 50.970597900000037, 25.8708866 ], [ 50.967468600000018, 25.871528800000018 ], [ 50.966046599999956, 25.870370800000039 ], [ 50.96604840000002, 25.8639371 ], [ 50.9586553, 25.856471700000036 ], [ 50.959082299999977, 25.854155599999981 ], [ 50.960647199999961, 25.853641299999971 ], [ 50.960933500000024, 25.847979600000034 ], [ 50.958658900000032, 25.84566280000001 ], [ 50.957380899999983, 25.8392285 ], [ 50.958378600000017, 25.833720900000031 ], [ 50.9555348, 25.833720099999965 ], [ 50.958378600000017, 25.833463699999978 ], [ 50.957952600000034, 25.830375199999963 ], [ 50.962077199999975, 25.828832200000015 ], [ 50.965490899999985, 25.824200500000035 ], [ 50.9700403, 25.825616699999973 ], [ 50.979708599999974, 25.8256182 ], [ 50.9861068, 25.8208584 ], [ 50.987672100000026, 25.8108216 ], [ 50.986250800000022, 25.808762499999979 ], [ 50.987672499999967, 25.807990400000044 ], [ 50.985114, 25.805159400000019 ], [ 50.9898048, 25.8036156 ], [ 50.99094239999998, 25.7984684 ], [ 50.9873896, 25.79538 ], [ 50.986537, 25.792548899999964 ], [ 50.979714800000039, 25.788945 ], [ 50.983269399999983, 25.776592299999987 ], [ 50.977727899999955, 25.772602 ], [ 50.968633, 25.77015579999998 ], [ 50.96934390000002, 25.767582200000025 ], [ 50.967497700000031, 25.765112 ], [ 50.9618135, 25.764724199999986 ], [ 50.96010780000001, 25.765882199999965 ], [ 50.958687099999963, 25.7647232 ], [ 50.958118, 25.766653800000036 ], [ 50.955844699999972, 25.7653664 ], [ 50.9551312, 25.772057400000023 ], [ 50.96067140000001, 25.780294499999975 ], [ 50.9592479, 25.786985499999989 ], [ 50.954982699999974, 25.790329900000039 ], [ 50.95441269999997, 25.793932599999966 ], [ 50.948725300000042, 25.798048399999981 ], [ 50.947301900000042, 25.802423 ], [ 50.942468200000043, 25.80345060000003 ], [ 50.940475800000037, 25.807825 ], [ 50.9308088, 25.808078100000017 ], [ 50.924278300000026, 25.794177499999979 ], [ 50.9194496, 25.7882556 ], [ 50.912345, 25.785163200000024 ], [ 50.912061899999983, 25.783618899999968 ], [ 50.908934899999977, 25.78387439999997 ], [ 50.906666, 25.777181499999976 ], [ 50.907947399999983, 25.77357940000001 ], [ 50.9056771, 25.768945500000026 ], [ 50.906958699999983, 25.766372600000039 ], [ 50.905255099999977, 25.764312700000044 ], [ 50.906391699999965, 25.7645709 ], [ 50.907959700000028, 25.757623 ], [ 50.910946299999956, 25.755051299999984 ], [ 50.911233, 25.751705800000021 ], [ 50.914075300000036, 25.750935499999969 ], [ 50.913225200000042, 25.747589200000029 ], [ 50.918340900000011, 25.7468202 ], [ 50.917489800000027, 25.744760800000041 ], [ 50.916068899999964, 25.744760099999983 ], [ 50.918201, 25.7427024 ], [ 50.916355400000043, 25.74141460000002 ], [ 50.917067, 25.7388414 ], [ 50.9112462, 25.733690699999986 ], [ 50.905564700000014, 25.732143 ], [ 50.9055656, 25.730856100000018 ], [ 50.9027253, 25.72956749999998 ], [ 50.9023035, 25.723647800000013 ], [ 50.893930199999978, 25.7151491 ], [ 50.8922311, 25.708971199999983 ], [ 50.893229199999979, 25.70408220000003 ], [ 50.8974944, 25.699452599999958 ], [ 50.898357900000043, 25.68607050000001 ], [ 50.897081599999957, 25.684525399999977 ], [ 50.899925299999971, 25.680409599999962 ], [ 50.896521, 25.675774699999984 ], [ 50.895673399999971, 25.670884099999988 ], [ 50.899509500000029, 25.667541099999966 ], [ 50.899514399999987, 25.661621800000031 ], [ 50.903211399999989, 25.654932900000013 ], [ 50.902364099999964, 25.6492703 ], [ 50.906342399999971, 25.6454124 ], [ 50.907339799999981, 25.641295199999966 ], [ 50.90989520000003, 25.641039500000037 ], [ 50.912452399999964, 25.638467400000028 ], [ 50.915011599999971, 25.63293519999997 ], [ 50.922395500000029, 25.629207900000036 ], [ 50.925802, 25.629467099999989 ], [ 50.927792800000027, 25.623677 ], [ 50.93631060000002, 25.620979099999971 ], [ 50.936593399999971, 25.623038 ], [ 50.946100800000046, 25.627674399999986 ], [ 50.945674200000013, 25.6305052 ], [ 50.9581637, 25.635785 ], [ 50.9646946, 25.63257009999996 ], [ 50.971790799999972, 25.638233599999957 ], [ 50.973350499999967, 25.644925400000037 ], [ 50.975337399999965, 25.647241900000036 ], [ 50.975195500000034, 25.649558300000027 ], [ 50.973207600000045, 25.6505874 ], [ 50.973491099999968, 25.652903599999973 ], [ 50.976046700000033, 25.652646800000042 ], [ 50.9746273, 25.650587600000016 ], [ 50.978176599999955, 25.648529199999967 ], [ 50.979739599999959, 25.643639599999965 ], [ 50.9828626, 25.644412 ], [ 50.983431, 25.641323800000023 ], [ 50.985134600000038, 25.640551900000016 ], [ 50.985134, 25.644669700000019 ], [ 50.9881151, 25.640809500000014 ], [ 50.986838399999968, 25.637463600000018 ], [ 50.979740899999982, 25.6348893 ], [ 50.9807351, 25.62897 ], [ 50.97378180000004, 25.621762699999969 ], [ 50.972504699999973, 25.6181594 ], [ 50.970660399999964, 25.616357500000028 ], [ 50.963280499999975, 25.615069 ], [ 50.965836, 25.612238600000023 ], [ 50.964984800000032, 25.6112089 ], [ 50.968107200000013, 25.610952199999989 ], [ 50.969101200000011, 25.606834700000011 ], [ 50.9696701, 25.6019449 ], [ 50.966975299999973, 25.598341 ], [ 50.960732299999989, 25.59499380000004 ], [ 50.954205, 25.593962499999975 ], [ 50.952501700000042, 25.5952488 ], [ 50.952216299999961, 25.599109100000014 ], [ 50.947674100000015, 25.601423800000042 ], [ 50.942846399999986, 25.606826699999971 ], [ 50.942843199999984, 25.6137755 ], [ 50.941992300000017, 25.612231 ], [ 50.9397206, 25.614289 ], [ 50.940575600000038, 25.607083199999966 ], [ 50.935750200000015, 25.60708109999997 ], [ 50.934046600000016, 25.60836709999997 ], [ 50.934328, 25.612742399999963 ], [ 50.929786300000032, 25.612740399999975 ], [ 50.932200200000011, 25.609653199999979 ], [ 50.932344599999965, 25.6063076 ], [ 50.9272386, 25.601157699999963 ], [ 50.9238325, 25.601670799999962 ], [ 50.921280400000043, 25.598066199999966 ], [ 50.919861, 25.598322899999978 ], [ 50.9194356, 25.597035799999976 ], [ 50.92312670000004, 25.594721499999981 ], [ 50.922844599999969, 25.5921477 ], [ 50.925825499999966, 25.59137710000002 ], [ 50.925684700000041, 25.589060700000029 ], [ 50.919869700000028, 25.585197200000017 ], [ 50.919588500000032, 25.581593900000041 ], [ 50.915899399999972, 25.5813346 ], [ 50.9170355, 25.580048299999966 ], [ 50.916186500000016, 25.576702 ], [ 50.9127824, 25.575156 ], [ 50.915905200000012, 25.573098799999968 ], [ 50.918463400000022, 25.56666610000001 ], [ 50.9125087, 25.561258100000014 ], [ 50.911375699999958, 25.5586837 ], [ 50.912654800000013, 25.554566500000039 ], [ 50.9101052, 25.549417599999988 ], [ 50.910959499999983, 25.545300400000034 ], [ 50.906565400000034, 25.54169450000002 ], [ 50.908270199999961, 25.538092399999964 ], [ 50.913236600000012, 25.534749699999967 ], [ 50.9145159, 25.531404600000037 ], [ 50.913097799999981, 25.5311464 ], [ 50.912390800000018, 25.5275429 ], [ 50.9060132, 25.522391600000013 ], [ 50.906156400000036, 25.519818 ], [ 50.909422, 25.515444899999981 ], [ 50.916088800000011, 25.5126176 ], [ 50.9149582, 25.506955 ], [ 50.912832499999972, 25.50592419999996 ], [ 50.912263, 25.50901230000003 ], [ 50.905456699999959, 25.508493299999987 ], [ 50.90290089999997, 25.512609500000035 ], [ 50.905452599999975, 25.5136407 ], [ 50.8977915, 25.517753500000037 ], [ 50.898494399999969, 25.524445400000037 ], [ 50.89707290000004, 25.528305 ], [ 50.888985200000015, 25.532674300000021 ], [ 50.889549199999962, 25.536278 ], [ 50.879903199999966, 25.537299700000013 ], [ 50.877063700000036, 25.540128500000034 ], [ 50.879046300000027, 25.5432186 ], [ 50.872805100000015, 25.5432133 ], [ 50.8715801, 25.541144399999979 ], [ 50.86761989999998, 25.543175399999981 ], [ 50.87189590000002, 25.563714200000017 ], [ 50.868953800000035, 25.571010600000029 ], [ 50.864444499999969, 25.571003499999975 ], [ 50.860510399999981, 25.5736004 ], [ 50.860077799999978, 25.584185200000039 ], [ 50.861493200000027, 25.587792900000025 ], [ 50.869875, 25.594364700000035 ], [ 50.872546500000027, 25.600170199999969 ], [ 50.874606400000019, 25.611954499999964 ], [ 50.879653399999988, 25.62159309999997 ], [ 50.878383, 25.624830799999984 ], [ 50.879906499999969, 25.6266398 ], [ 50.878522500000031, 25.626852600000024 ], [ 50.879745599999978, 25.6317376 ], [ 50.87356190000002, 25.6330344 ], [ 50.87384909999998, 25.629688900000044 ], [ 50.869875199999981, 25.629170699999978 ], [ 50.8670802, 25.6324921 ], [ 50.865149, 25.6388664 ], [ 50.86261810000002, 25.64085619999997 ], [ 50.85992629999997, 25.640098900000016 ], [ 50.859357, 25.641385200000041 ], [ 50.855385200000022, 25.638807600000021 ], [ 50.8531136, 25.63893459999996 ], [ 50.852258699999972, 25.641507300000018 ], [ 50.8494209, 25.640345900000025 ], [ 50.846145900000018, 25.647677800000043 ], [ 50.8469336, 25.650950500000022 ], [ 50.848620699999969, 25.650537100000012 ], [ 50.846762400000046, 25.6512078 ], [ 50.847641699999969, 25.652812299999969 ], [ 50.846303800000022, 25.653441900000015 ], [ 50.842595299999957, 25.649218100000034 ], [ 50.845440600000011, 25.64458859999997 ], [ 50.84274689999998, 25.6414975 ], [ 50.8460181, 25.637125700000038 ], [ 50.844882099999985, 25.6373818 ], [ 50.8437498, 25.634807100000042 ], [ 50.837505199999974, 25.6337708 ], [ 50.84233530000003, 25.630945 ], [ 50.842055599999981, 25.627727300000011 ], [ 50.852284100000034, 25.6209182 ], [ 50.853993199999955, 25.616030100000028 ], [ 50.8508688, 25.6175712 ], [ 50.846888099999966, 25.622714300000013 ], [ 50.842627499999956, 25.624639599999973 ], [ 50.836382499999985, 25.6242471 ], [ 50.838659600000014, 25.619874399999961 ], [ 50.843375400000021, 25.615733199999976 ], [ 50.842387, 25.613609699999959 ], [ 50.835382500000023, 25.6213284 ], [ 50.832056399999978, 25.6223824 ], [ 50.82284760000001, 25.622895 ], [ 50.822619599999975, 25.6200885 ], [ 50.817255599999974, 25.615287 ], [ 50.815061299999961, 25.617214599999979 ], [ 50.817750299999965, 25.619586300000016 ], [ 50.816464200000041, 25.620697400000022 ], [ 50.8181716, 25.6213229 ], [ 50.816150600000029, 25.622214 ], [ 50.815035400000042, 25.617906 ], [ 50.81470010000001, 25.6195506 ], [ 50.805650300000046, 25.615323 ], [ 50.801347, 25.6152654 ], [ 50.800404499999971, 25.610184599999982 ], [ 50.793636299999967, 25.6002436 ], [ 50.798389300000032, 25.596941 ], [ 50.79837730000002, 25.59446530000001 ], [ 50.803825499999967, 25.59340580000001 ], [ 50.807068, 25.590589499999957 ], [ 50.8069421, 25.593557200000014 ], [ 50.816519900000031, 25.599135599999986 ], [ 50.825150699999966, 25.599022 ], [ 50.827807200000031, 25.597171800000037 ], [ 50.826304400000033, 25.592823599999978 ], [ 50.835692199999983, 25.572636299999981 ], [ 50.836759, 25.565031400000024 ], [ 50.83246739999997, 25.560556300000034 ], [ 50.835268900000038, 25.557531 ], [ 50.83561789999996, 25.554379400000013 ], [ 50.8301405, 25.545408 ], [ 50.823973299999977, 25.543150599999972 ], [ 50.823392599999984, 25.536373 ], [ 50.8199276, 25.529754 ], [ 50.818087200000036, 25.528955800000016 ], [ 50.819847799999962, 25.527364599999988 ], [ 50.8192322, 25.52548240000004 ], [ 50.82759350000002, 25.524152400000041 ], [ 50.828633800000034, 25.5198453 ], [ 50.836731900000032, 25.509910800000032 ], [ 50.8336916, 25.503963800000026 ], [ 50.836439299999981, 25.502399299999986 ], [ 50.843588200000042, 25.4926428 ], [ 50.841261700000018, 25.4899003 ], [ 50.837919599999978, 25.4900204 ], [ 50.837613400000045, 25.487832399999974 ], [ 50.835113599999978, 25.489323399999972 ], [ 50.835034099999973, 25.486718299999986 ], [ 50.843243, 25.4782876 ], [ 50.84342, 25.47636239999996 ], [ 50.8477762, 25.474626799999974 ], [ 50.846945099999971, 25.471882099999984 ], [ 50.849038299999968, 25.470810699999976 ], [ 50.849374199999964, 25.466064 ], [ 50.83661570000001, 25.461033599999968 ], [ 50.829333800000043, 25.460901100000019 ], [ 50.824975899999977, 25.464414500000018 ], [ 50.830473899999959, 25.462106800000036 ], [ 50.824039300000024, 25.466393299999964 ], [ 50.822199899999973, 25.490002799999964 ], [ 50.8195284, 25.4972404 ], [ 50.815198699999961, 25.497286 ], [ 50.812286300000039, 25.499832699999988 ], [ 50.809088799999977, 25.5164133 ], [ 50.808247700000017, 25.518293500000041 ], [ 50.804736400000017, 25.519458900000011 ], [ 50.8033343, 25.524411399999977 ], [ 50.798955, 25.530040200000034 ], [ 50.7926384, 25.529383599999974 ], [ 50.790375700000013, 25.531493899999965 ], [ 50.789166200000032, 25.5286766 ], [ 50.7834314, 25.527982300000026 ], [ 50.7823011, 25.524583299999989 ], [ 50.777958300000037, 25.521333699999968 ], [ 50.776247200000036, 25.520551399999988 ], [ 50.7745764, 25.521606499999979 ], [ 50.772633800000023, 25.518333499999976 ], [ 50.771081, 25.519930899999984 ], [ 50.7700917, 25.519238199999958 ], [ 50.772070899999989, 25.518695099999963 ], [ 50.7711672, 25.5164466 ], [ 50.7588505, 25.504437799999987 ], [ 50.7568033, 25.504118400000028 ], [ 50.757360099999971, 25.4997996 ], [ 50.761406800000039, 25.50160750000002 ], [ 50.7648402, 25.498964199999982 ], [ 50.769757100000035, 25.488626400000033 ], [ 50.764607500000011, 25.478396 ], [ 50.7612164, 25.460209700000011 ], [ 50.755479200000039, 25.442932800000037 ], [ 50.756932, 25.433583399999979 ], [ 50.750374600000015, 25.424736899999964 ], [ 50.749990400000023, 25.42192869999996 ], [ 50.751972599999981, 25.419374600000019 ], [ 50.7555335, 25.419801399999983 ], [ 50.75857419999997, 25.4156688 ], [ 50.758427199999979, 25.410632899999971 ], [ 50.7568945, 25.409821299999965 ], [ 50.7581182, 25.409211699999975 ], [ 50.753890200000015, 25.402403899999978 ], [ 50.7567883, 25.402099099999983 ], [ 50.76286259999997, 25.394309 ], [ 50.762521100000043, 25.3911211 ], [ 50.7592068, 25.386192 ], [ 50.760617500000016, 25.386324200000029 ], [ 50.7596921, 25.380489299999972 ], [ 50.762882700000034, 25.36830439999996 ], [ 50.761678300000035, 25.363675400000027 ], [ 50.763227300000032, 25.363176300000031 ], [ 50.763520699999972, 25.361117699999966 ], [ 50.761201400000012, 25.3582273 ], [ 50.762424, 25.355809399999959 ], [ 50.7596245, 25.351817100000037 ], [ 50.760982, 25.352063099999963 ], [ 50.761135399999965, 25.351380399999965 ], [ 50.759636, 25.351283300000013 ], [ 50.762148699999962, 25.351063899999978 ], [ 50.763302699999969, 25.351588300000024 ], [ 50.765387499999981, 25.3494507 ], [ 50.766661799999987, 25.341951800000015 ], [ 50.7649488, 25.3349818 ], [ 50.766789199999963, 25.3310153 ], [ 50.765755799999987, 25.3245981 ], [ 50.7684717, 25.316176 ], [ 50.769608800000022, 25.301260899999964 ], [ 50.766799500000012, 25.293556699999961 ], [ 50.763803, 25.293282600000019 ], [ 50.765787300000021, 25.2928552 ], [ 50.763905600000022, 25.291710299999956 ], [ 50.763098500000034, 25.293556699999961 ], [ 50.760953600000022, 25.293907500000032 ], [ 50.7642167, 25.291113200000023 ], [ 50.763722699999988, 25.29004520000003 ], [ 50.7630316, 25.291077299999984 ], [ 50.7633214, 25.289642 ], [ 50.7616403, 25.290121799999973 ], [ 50.763745, 25.289089600000011 ], [ 50.764248599999981, 25.274641300000042 ], [ 50.762914299999984, 25.271411699999987 ], [ 50.760147500000031, 25.2733398 ], [ 50.763754300000031, 25.27045289999997 ], [ 50.761521, 25.266909299999959 ], [ 50.763144799999957, 25.262490199999984 ], [ 50.762299600000013, 25.257908699999984 ], [ 50.764235799999987, 25.241833100000019 ], [ 50.763447, 25.239725 ], [ 50.7611369, 25.2395582 ], [ 50.764983600000043, 25.239683299999957 ], [ 50.766807100000023, 25.2355273 ], [ 50.763684700000042, 25.216673099999984 ], [ 50.765341, 25.214142300000017 ], [ 50.76511960000002, 25.210883400000025 ], [ 50.766452299999976, 25.2113457 ], [ 50.768108499999961, 25.2087994 ], [ 50.7651311, 25.202151 ], [ 50.762744, 25.2004406 ], [ 50.7648864, 25.201305900000012 ], [ 50.763492799999973, 25.2002193 ], [ 50.766325300000034, 25.197760699999957 ], [ 50.766249499999979, 25.184235299999965 ], [ 50.767979599999954, 25.183968900000039 ], [ 50.768568199999983, 25.180208 ], [ 50.770249299999989, 25.178860200000027 ], [ 50.774645500000027, 25.162441099999974 ], [ 50.773716275235778, 25.160566978677043 ], [ 50.775641899999954, 25.159096700000013 ], [ 50.775653799999965, 25.1526622 ], [ 50.7738218, 25.149056099999964 ], [ 50.775308700000011, 25.14474890000001 ], [ 50.773440984673876, 25.137880448473013 ], [ 50.774275300000035, 25.133356600000031 ], [ 50.770635332789546, 25.118972057221164 ], [ 50.771060400000046, 25.113533300000043 ], [ 50.773617, 25.106845400000019 ], [ 50.794276900000035, 25.091947299999958 ], [ 50.796402400000041, 25.0888617 ], [ 50.796797143323225, 25.084225036736626 ], [ 50.804051099999981, 25.077804599999961 ], [ 50.8061885, 25.066225100000036 ], [ 50.8104362, 25.060310799999982 ], [ 50.8130136, 25.037664199999984 ], [ 50.800182199999966, 25.023748899999973 ], [ 50.800892500000025, 25.0209186 ], [ 50.797755680990328, 25.015985710843744 ], [ 50.796120199999962, 25.0028952 ], [ 50.7975366, 25.0003233 ], [ 50.7958534, 24.9933717 ], [ 50.796527716522711, 24.98578632537772 ], [ 50.797424, 24.983206500000041 ], [ 50.800250500000018, 24.9815378 ], [ 50.803792499999986, 24.973563500000026 ], [ 50.814115300000026, 24.963024 ], [ 50.822168599999962, 24.958143400000029 ], [ 50.8260066, 24.939616099999981 ], [ 50.834482, 24.9347354 ], [ 50.85035160000001, 24.920861599999963 ], [ 50.851719899999978, 24.919052899999969 ], [ 50.850377090634147, 24.912041875889898 ], [ 50.853705699999971, 24.910561 ], [ 50.858009800000026, 24.903815099999957 ], [ 50.8586645037118, 24.89271269995966 ], [ 50.861773699999965, 24.887918399999961 ], [ 50.8638222, 24.8787313 ], [ 50.8600973, 24.873245699999988 ], [ 50.859092099999955, 24.866398899999961 ], [ 50.861801899999989, 24.862694200000032 ], [ 50.862757900000041, 24.8569314 ], [ 50.858574899999972, 24.847762699999961 ], [ 50.858864500000045, 24.841328200000032 ], [ 50.8546388, 24.83669109999996 ], [ 50.85435949999998, 24.834374300000025 ], [ 50.8576252, 24.821612499999976 ], [ 50.862419400000014, 24.814562800000036 ], [ 50.867217900000028, 24.8104488 ], [ 50.8707417, 24.801261400000016 ], [ 50.869071800000029, 24.790888600000013 ], [ 50.866009904858778, 24.78828500620088 ], [ 50.861398873855443, 24.772120713335241 ], [ 50.862750100000021, 24.77029140000003 ], [ 50.86007769999997, 24.7656558 ], [ 50.837259900000021, 24.753406100000038 ], [ 50.811624800000018, 24.744367799999964 ], [ 50.843309399999981, 24.696243400000014 ], [ 50.873393, 24.646014099999988 ], [ 50.928351, 24.54682 ], [ 50.93426360000003, 24.541516699999985 ], [ 50.994484100000015, 24.503973799999986 ], [ 51.024559100000019, 24.492388 ], [ 51.098534499999978, 24.470753399999964 ], [ 51.155556099999963, 24.478793699999976 ], [ 51.170684900000019, 24.485622500000023 ], [ 51.220469799999954, 24.493202300000036 ], [ 51.2658281, 24.505604099999964 ], [ 51.301427599999968, 24.5054844 ], [ 51.298802600000023, 24.508541700000016 ], [ 51.295734600000017, 24.519873400000044 ], [ 51.296870799999972, 24.524504299999958 ], [ 51.297007700000016, 24.522702099999968 ], [ 51.2986971, 24.523213800000029 ], [ 51.297435900000011, 24.525532799999969 ], [ 51.300814699999975, 24.52655569999996 ], [ 51.3019604, 24.535047600000034 ], [ 51.301143900000035, 24.546632200000026 ], [ 51.302836099999979, 24.5481733 ], [ 51.2997663, 24.558990099999964 ], [ 51.299794500000026, 24.570830399999974 ], [ 51.304894300000015, 24.584719699999965 ], [ 51.308706, 24.589216 ], [ 51.316318399999957, 24.5939625 ], [ 51.3173065, 24.595247299999986 ], [ 51.316895, 24.599366600000025 ], [ 51.316743400000043, 24.5952485 ], [ 51.3140657, 24.59370979999996 ], [ 51.3115378, 24.596031500000034 ], [ 51.3130889, 24.597315400000038 ], [ 51.311832100000018, 24.601178899999962 ], [ 51.308176399999972, 24.602859099999982 ], [ 51.3022449, 24.594763500000013 ], [ 51.298017299999977, 24.592712899999988 ], [ 51.292402099999975, 24.599158699999965 ], [ 51.290163, 24.6048259 ], [ 51.2881816, 24.600196500000035 ], [ 51.286501399999985, 24.6040606 ], [ 51.284521799999972, 24.6002035 ], [ 51.282563300000014, 24.605612499999982 ], [ 51.281716600000038, 24.604712600000042 ], [ 51.280173800000014, 24.607418800000044 ], [ 51.282724899999977, 24.61513580000004 ], [ 51.286242, 24.613842300000041 ], [ 51.2837202, 24.619252400000033 ], [ 51.279770300000024, 24.615656100000013 ], [ 51.277784699999962, 24.608967600000028 ], [ 51.276380799999977, 24.610772 ], [ 51.271034700000037, 24.612325899999984 ], [ 51.2707616, 24.6161874 ], [ 51.2597769, 24.614405099999978 ], [ 51.257518199999986, 24.6113203 ], [ 51.254701199999964, 24.6105527 ], [ 51.246263800000044, 24.615200100000031 ], [ 51.2426016, 24.614176299999965 ], [ 51.241753, 24.612118399999957 ], [ 51.2358422, 24.613028300000014 ], [ 51.2335933, 24.614962900000034 ], [ 51.2333098, 24.613933599999957 ], [ 51.231062400000027, 24.6166393 ], [ 51.231339400000032, 24.614194 ], [ 51.2290858, 24.613553500000037 ], [ 51.225994500000013, 24.616776099999957 ], [ 51.221211500000038, 24.618842499999957 ], [ 51.220370800000026, 24.621160199999967 ], [ 51.2167099, 24.620779 ], [ 51.217269099999982, 24.6185907 ], [ 51.215580200000041, 24.6188506 ], [ 51.2155829, 24.620395099999989 ], [ 51.213622599999987, 24.620143100000011 ], [ 51.2156012, 24.626071199999963 ], [ 51.218978600000028, 24.625165 ], [ 51.220098799999988, 24.626566 ], [ 51.218693100000031, 24.627855100000037 ], [ 51.221086900000032, 24.628366399999976 ], [ 51.217285600000018, 24.6281144 ], [ 51.217005899999968, 24.629144499999963 ], [ 51.214747900000013, 24.626058900000011 ], [ 51.214331099999988, 24.629663099999973 ], [ 51.215603700000031, 24.632492599999964 ], [ 51.2179981, 24.633261499999989 ], [ 51.217861300000045, 24.635320800000024 ], [ 51.222370600000019, 24.637373400000037 ], [ 51.220122299999979, 24.63995080000004 ], [ 51.2206904, 24.642781200000016 ], [ 51.224069399999983, 24.642518899999985 ], [ 51.226611, 24.646376 ], [ 51.22800789999998, 24.640196300000014 ], [ 51.233074599999981, 24.6389016 ], [ 51.232376699999968, 24.6425062 ], [ 51.233360600000019, 24.641346 ], [ 51.237587199999965, 24.64249810000004 ], [ 51.23688749999998, 24.645073200000031 ], [ 51.240698, 24.649313599999964 ], [ 51.247458300000027, 24.6498175 ], [ 51.257309400000025, 24.646841300000041 ], [ 51.259710800000036, 24.65069820000004 ], [ 51.263236199999959, 24.652879500000044 ], [ 51.265769200000022, 24.651974599999956 ], [ 51.267746899999963, 24.65493070000003 ], [ 51.275915799999957, 24.6554306 ], [ 51.277177199999969, 24.652983600000042 ], [ 51.276319399999956, 24.647064899999979 ], [ 51.2809646, 24.646155100000019 ], [ 51.283223099999987, 24.648596599999969 ], [ 51.282975199999989, 24.663526 ], [ 51.28521749999998, 24.658631099999958 ], [ 51.283262599999965, 24.666099299999974 ], [ 51.285937599999961, 24.665837 ], [ 51.28664629999998, 24.667637399999961 ], [ 51.286367, 24.6686674 ], [ 51.2846758, 24.668155800000044 ], [ 51.2846811, 24.670472399999962 ], [ 51.289334099999969, 24.673037500000014 ], [ 51.288355299999985, 24.675870799999963 ], [ 51.29102789999996, 24.674578599999982 ], [ 51.297875400000045, 24.651657 ], [ 51.301105799999988, 24.64830440000004 ], [ 51.300535699999983, 24.645474099999984 ], [ 51.303339499999979, 24.6403206 ], [ 51.30460870000001, 24.640961099999966 ], [ 51.306293100000019, 24.638770299999976 ], [ 51.306284899999966, 24.635424 ], [ 51.3081262, 24.6400534 ], [ 51.306587300000025, 24.643917499999976 ], [ 51.309399600000013, 24.642367499999981 ], [ 51.31081540000001, 24.645453300000039 ], [ 51.313346199999977, 24.643903699999989 ], [ 51.313198500000013, 24.641330100000033 ], [ 51.3161494, 24.638749799999967 ], [ 51.315882300000027, 24.6445414 ], [ 51.320932800000016, 24.637195299999956 ], [ 51.321504499999982, 24.640540199999958 ], [ 51.322629499999984, 24.63989390000004 ], [ 51.3215111, 24.643114200000035 ], [ 51.324610400000012, 24.643622299999976 ], [ 51.327434600000011, 24.646705 ], [ 51.325198900000032, 24.653402100000029 ], [ 51.328006499999987, 24.650049800000037 ], [ 51.329699800000029, 24.6513331 ], [ 51.328858, 24.652492800000022 ], [ 51.334772299999976, 24.652479800000012 ], [ 51.338436700000031, 24.653630199999984 ], [ 51.338723200000025, 24.65543139999998 ], [ 51.3429437, 24.65387740000001 ], [ 51.344079800000031, 24.657349100000022 ], [ 51.347305899999974, 24.652837899999977 ], [ 51.34716109999998, 24.651293800000026 ], [ 51.34462510000003, 24.650784800000011 ], [ 51.343629100000044, 24.64718360000003 ], [ 51.344611699999987, 24.645894400000032 ], [ 51.347152199999954, 24.648075899999963 ], [ 51.347711599999968, 24.6466595 ], [ 51.349121199999978, 24.647170899999956 ], [ 51.3482628, 24.642282399999957 ], [ 51.353047300000021, 24.6412416 ], [ 51.354460100000033, 24.642911100000017 ], [ 51.357124400000032, 24.639172799999972 ], [ 51.356545900000036, 24.633768899999961 ], [ 51.357245199999987, 24.631965499999961 ], [ 51.358372900000035, 24.632477699999974 ], [ 51.358222899999973, 24.629389199999959 ], [ 51.3560968, 24.624246399999969 ], [ 51.358071699999982, 24.625528700000018 ], [ 51.357221, 24.62347149999998 ], [ 51.358349499999967, 24.624241099999974 ], [ 51.358758100000024, 24.619607 ], [ 51.352120299999967, 24.611900699999975 ], [ 51.352112300000016, 24.609069500000022 ], [ 51.349576299999974, 24.608303100000025 ], [ 51.3484387, 24.604187400000018 ], [ 51.343930099999987, 24.602653500000024 ], [ 51.346632500000034, 24.612943 ], [ 51.3456531, 24.615004500000012 ], [ 51.343397200000041, 24.6137227 ], [ 51.3415387, 24.603431 ], [ 51.343643199999967, 24.600723 ], [ 51.347491499999961, 24.602041899999957 ], [ 51.343065799999977, 24.5954482 ], [ 51.3394068, 24.595714 ], [ 51.3354801, 24.601128100000022 ], [ 51.3326655, 24.601391699999983 ], [ 51.331250499999989, 24.598563500000012 ], [ 51.3307858, 24.58260590000004 ], [ 51.336403, 24.577960299999976 ], [ 51.3383622, 24.573837600000012 ], [ 51.3366404, 24.5614863 ], [ 51.3345213, 24.558144800000012 ], [ 51.33649680000002, 24.560199600000029 ], [ 51.337050199999979, 24.556594800000017 ], [ 51.33902180000004, 24.5572334 ], [ 51.352709799999985, 24.571230699999965 ], [ 51.368865064403913, 24.579823374586493 ], [ 51.3675204, 24.582778099999988 ], [ 51.364988500000031, 24.583299100000019 ], [ 51.364417400000029, 24.580469099999988 ], [ 51.361147099999982, 24.584506800000025 ], [ 51.367244199999973, 24.5845806 ], [ 51.3694998, 24.585862 ], [ 51.37007489999997, 24.589979 ], [ 51.372326400000013, 24.589844200000041 ], [ 51.373743899999965, 24.593186900000038 ], [ 51.37810319999997, 24.592018299999982 ], [ 51.377690099999981, 24.594850600000026 ], [ 51.375156, 24.5947278 ], [ 51.3740342, 24.596146799999982 ], [ 51.371782899999985, 24.596409699999974 ], [ 51.371213799999971, 24.594351899999975 ], [ 51.3706591, 24.597184599999963 ], [ 51.3734769, 24.5980782 ], [ 51.3762894, 24.597170599999959 ], [ 51.371798899999973, 24.6018149 ], [ 51.374616400000036, 24.6025802 ], [ 51.375175600000034, 24.601291699999969 ], [ 51.375180900000025, 24.603093500000014 ], [ 51.377430199999971, 24.602058299999982 ], [ 51.377039, 24.612612499999983 ], [ 51.3838433, 24.628039 ], [ 51.38386219999996, 24.634216499999958 ], [ 51.390355699999979, 24.639605100000036 ], [ 51.3899426, 24.6424374 ], [ 51.395579700000027, 24.6439672 ], [ 51.3960098, 24.646539899999972 ], [ 51.39348159999998, 24.64860580000002 ], [ 51.395171199999979, 24.6486013 ], [ 51.39616560000001, 24.651172600000034 ], [ 51.4002489, 24.651161900000037 ], [ 51.397679300000021, 24.654168799999962 ], [ 51.403918400000038, 24.653726 ], [ 51.399803099999971, 24.643698599999983 ], [ 51.396273499999964, 24.6408767 ], [ 51.3963973, 24.635341799999985 ], [ 51.404571499999982, 24.637765699999989 ], [ 51.4030346, 24.641630800000044 ], [ 51.411379299999979, 24.652804300000039 ], [ 51.415891099999989, 24.654465399999989 ], [ 51.4143262, 24.6498368 ], [ 51.415303899999984, 24.647260099999965 ], [ 51.4154502, 24.649061499999977 ], [ 51.4171408, 24.649314200000013 ], [ 51.415160099999987, 24.646488299999966 ], [ 51.4155736, 24.643655699999986 ], [ 51.416707799999969, 24.645969300000012 ], [ 51.417265899999961, 24.6444233 ], [ 51.419657499999957, 24.6439018 ], [ 51.4178257, 24.643392300000041 ], [ 51.417249700000042, 24.639532900000013 ], [ 51.4186587, 24.639786300000019 ], [ 51.4229191, 24.650585 ], [ 51.425541399999986, 24.6523357 ], [ 51.429116400000019, 24.650953 ], [ 51.435474400000011, 24.657241199999977 ], [ 51.4380442, 24.667272200000031 ], [ 51.432290099999975, 24.6729515 ], [ 51.4356685, 24.672427 ], [ 51.434144600000032, 24.6798957 ], [ 51.440765800000044, 24.6801339 ], [ 51.4404625, 24.6739573 ], [ 51.4417603, 24.6827048 ], [ 51.453431300000027, 24.716131 ], [ 51.459102799999975, 24.725894500000031 ], [ 51.477938300000034, 24.7508025 ], [ 51.482211800000044, 24.762628599999989 ], [ 51.482290399999975, 24.782962 ], [ 51.480865899999969, 24.779105799999964 ], [ 51.4794632, 24.78091190000001 ], [ 51.476363899999974, 24.781436499999984 ], [ 51.475690699999966, 24.778180300000038 ], [ 51.473532, 24.778099500000014 ], [ 51.474080300000033, 24.7739795 ], [ 51.471546, 24.7747597 ], [ 51.469586199999981, 24.778369399999963 ], [ 51.466490800000017, 24.779923400000023 ], [ 51.464814699999984, 24.784046799999956 ], [ 51.467901500000032, 24.7801765 ], [ 51.46791110000003, 24.782750299999975 ], [ 51.4701748, 24.784930399999968 ], [ 51.4789062, 24.782715500000027 ], [ 51.479480900000041, 24.7855448 ], [ 51.482863100000017, 24.785276600000014 ], [ 51.483138100000033, 24.783474 ], [ 51.485690500000011, 24.787326499999981 ], [ 51.484289900000036, 24.7896476 ], [ 51.482591099999986, 24.78785139999998 ], [ 51.480340700000035, 24.789145500000028 ], [ 51.477237300000034, 24.7886406 ], [ 51.476946400000031, 24.7863252 ], [ 51.475254899999968, 24.7863305 ], [ 51.474699800000046, 24.788648799999965 ], [ 51.47300140000003, 24.78685250000002 ], [ 51.4716013, 24.7894307 ], [ 51.476681300000038, 24.790701499999987 ], [ 51.475138800000039, 24.793023 ], [ 51.475298, 24.7976554 ], [ 51.479407800000033, 24.803304799999978 ], [ 51.479283100000018, 24.807423499999967 ], [ 51.4812698, 24.810763099999974 ], [ 51.482815499999987, 24.80947110000001 ], [ 51.4830464, 24.7963437 ], [ 51.486288, 24.7959466 ], [ 51.487800499999977, 24.793460199999981 ], [ 51.486542399999976, 24.7888682 ], [ 51.490067499999967, 24.797786800000029 ], [ 51.4920978, 24.81521860000003 ], [ 51.49617019999998, 24.822766499999979 ], [ 51.4950294, 24.820704800000012 ], [ 51.493103099999956, 24.824096499999978 ], [ 51.491514499999965, 24.823566800000027 ], [ 51.493190299999981, 24.8246808 ], [ 51.488429499999974, 24.831310199999987 ], [ 51.4893036, 24.833387 ], [ 51.493216700000033, 24.835807799999973 ], [ 51.497558199999979, 24.833264500000038 ], [ 51.500546100000022, 24.835794400000019 ], [ 51.500887600000034, 24.840978300000035 ], [ 51.504204600000037, 24.840570499999956 ], [ 51.503023199999987, 24.844176100000034 ], [ 51.507244700000044, 24.845233799999974 ], [ 51.5053753, 24.840358299999984 ], [ 51.514019100000027, 24.85802 ], [ 51.531617200000021, 24.869774800000041 ], [ 51.554728700000027, 24.899224700000019 ], [ 51.561384499999974, 24.904970100000043 ], [ 51.563138599999981, 24.902477300000022 ], [ 51.561697400000014, 24.9055525 ], [ 51.568166599999977, 24.9147862 ], [ 51.5679126, 24.91689910000002 ], [ 51.573388799999961, 24.912525099999957 ], [ 51.567831799999986, 24.917126099999972 ], [ 51.567776799999962, 24.917934200000044 ], [ 51.5707163, 24.921097899999975 ], [ 51.568214899999973, 24.917265 ], [ 51.570752499999969, 24.920461499999988 ], [ 51.574278799999973, 24.917746599999976 ], [ 51.570844500000035, 24.920602600000027 ], [ 51.5712895, 24.921816700000029 ], [ 51.584117700000029, 24.940326 ], [ 51.5817021, 24.940091300000041 ], [ 51.5825405, 24.941368600000033 ], [ 51.5837845, 24.94233609999997 ], [ 51.588822800000045, 24.9400371 ], [ 51.585273700000023, 24.9421153 ], [ 51.5942433, 24.956121900000014 ], [ 51.5925374, 24.9575226 ], [ 51.595694099999967, 24.962574 ], [ 51.59784820000003, 24.961539700000021 ], [ 51.601992700000018, 24.967986399999983 ], [ 51.595069399999971, 24.970322600000014 ], [ 51.589596899999968, 24.962895 ], [ 51.581533099999966, 24.964119499999956 ], [ 51.588642799999981, 24.976041399999968 ], [ 51.597472899999971, 24.981155299999966 ], [ 51.6046363, 24.9810398 ], [ 51.605117600000028, 24.985184600000018 ], [ 51.609244199999956, 24.990015499999959 ], [ 51.620635899999975, 24.993896700000015 ], [ 51.6203742, 24.996593799999975 ], [ 51.623383899999972, 25.001606799999973 ], [ 51.625194600000043, 25.009555100000011 ], [ 51.657389400000028, 25.022356400000042 ], [ 51.659155200000029, 25.025508 ], [ 51.656998099999981, 25.026791700000025 ], [ 51.610342599999981, 25.0059901 ], [ 51.610257400000037, 25.00082160000002 ], [ 51.6049487, 25.000850800000038 ], [ 51.606671800000015, 25.003005499999972 ], [ 51.603815799999964, 25.003077499999979 ], [ 51.603444599999982, 24.996461500000041 ], [ 51.5990286, 24.9966521 ], [ 51.599459899999978, 25.006875399999981 ], [ 51.592419600000014, 25.0339803 ], [ 51.6008053, 25.035994500000033 ], [ 51.60669750000001, 25.0148267 ], [ 51.61007280000004, 25.015326399999957 ], [ 51.610393600000023, 25.0131456 ], [ 51.608673800000012, 25.012363899999976 ], [ 51.6151476, 25.014595300000039 ], [ 51.654179099999972, 25.033198499999973 ], [ 51.644597499999975, 25.039470400000038 ], [ 51.6294738, 25.0423028 ], [ 51.620765, 25.041751 ], [ 51.620013900000025, 25.0401141 ], [ 51.627001499999977, 25.0225608 ], [ 51.616059899999989, 25.0375344 ], [ 51.625869, 25.022050899999989 ], [ 51.6236042, 25.021030899999971 ], [ 51.623312600000027, 25.019230500000042 ], [ 51.620969500000044, 25.0198901 ], [ 51.620374700000035, 25.022518899999987 ], [ 51.6178076, 25.02081680000002 ], [ 51.618825500000021, 25.0256837 ], [ 51.6149801, 25.0195145 ], [ 51.616982600000036, 25.024404500000038 ], [ 51.616009800000015, 25.027497 ], [ 51.613831700000013, 25.020003499999962 ], [ 51.6123707, 25.0207317 ], [ 51.6107507, 25.049366 ], [ 51.6127505, 25.0537629 ], [ 51.614950500000035, 25.041657 ], [ 51.615384, 25.0437143 ], [ 51.609148699999963, 25.068190500000028 ], [ 51.614846300000025, 25.0774325 ], [ 51.6102892, 25.0702448 ], [ 51.609447900000028, 25.0715351 ], [ 51.615024600000034, 25.08489570000004 ], [ 51.619148700000025, 25.090025899999965 ], [ 51.620107500000046, 25.084102499999958 ], [ 51.618668700000015, 25.078960899999977 ], [ 51.61512, 25.075629799999962 ], [ 51.61539370000002, 25.07382710000002 ], [ 51.619801699999968, 25.079470799999978 ], [ 51.621239299999985, 25.084355 ], [ 51.620285699999954, 25.0913081 ], [ 51.621417499999986, 25.091560800000043 ], [ 51.617946300000014, 25.103929100000041 ], [ 51.619987100000031, 25.1162744 ], [ 51.617858799999972, 25.137620300000027 ], [ 51.620646100000023, 25.146348500000023 ], [ 51.61128150000004, 25.159877100000013 ], [ 51.61041429999996, 25.164329199999965 ], [ 51.613247299999976, 25.1660224 ], [ 51.6179569, 25.162866700000016 ], [ 51.618185800000028, 25.160978 ], [ 51.618318800000019, 25.162918200000014 ], [ 51.611216299999974, 25.167870499999964 ], [ 51.6106155, 25.16967660000001 ], [ 51.611774200000035, 25.173385899999964 ], [ 51.615489300000029, 25.178319100000021 ], [ 51.617187700000045, 25.178569300000028 ], [ 51.615919299999987, 25.179346899999974 ], [ 51.616787200000033, 25.183203799999973 ], [ 51.620482499999987, 25.189744900000019 ], [ 51.618880500000039, 25.202141400000041 ], [ 51.619592599999983, 25.2014604 ], [ 51.620240799999969, 25.206242 ], [ 51.6239876, 25.206160599999968 ], [ 51.625363100000044, 25.204786499999962 ], [ 51.624535699999974, 25.206209099999985 ], [ 51.620312599999963, 25.206827199999967 ], [ 51.6197173, 25.206184299999975 ], [ 51.6201562, 25.2071367 ], [ 51.624619399999972, 25.206633899999961 ], [ 51.619556, 25.207753400000041 ], [ 51.625143900000026, 25.206929099999961 ], [ 51.625895899999982, 25.204928100000043 ], [ 51.625290399999976, 25.207106 ], [ 51.6195929, 25.207908700000011 ], [ 51.6199501, 25.211548100000044 ], [ 51.617362300000011, 25.212356499999963 ], [ 51.6053943, 25.224108400000031 ], [ 51.601997, 25.2303855 ], [ 51.602031300000014, 25.235892199999984 ], [ 51.599682800000032, 25.240875099999979 ], [ 51.600003800000039, 25.24256769999996 ], [ 51.6149598, 25.2477681 ], [ 51.614716300000019, 25.2491495 ], [ 51.6180814, 25.2517753 ], [ 51.614918, 25.256413099999961 ], [ 51.61721340000004, 25.256010899999989 ], [ 51.617588900000023, 25.258203799999976 ], [ 51.620442799999985, 25.251721900000032 ], [ 51.6220092, 25.253041599999978 ], [ 51.62563609999998, 25.251061600000021 ], [ 51.63065659999998, 25.252818399999985 ], [ 51.6089624, 25.30202910000002 ], [ 51.6039719, 25.3002007 ], [ 51.60128540000003, 25.293936500000033 ], [ 51.5957482, 25.287977500000011 ], [ 51.590308699999973, 25.2951437 ], [ 51.585884099999987, 25.293571300000014 ], [ 51.589974500000032, 25.2849867 ], [ 51.587983200000032, 25.2859539 ], [ 51.5868342, 25.282589100000038 ], [ 51.582686900000041, 25.28661110000002 ], [ 51.582912200000031, 25.289362699999959 ], [ 51.58102659999998, 25.290773199999958 ], [ 51.581235899999974, 25.293719700000036 ], [ 51.584531299999966, 25.294490400000033 ], [ 51.581397700000039, 25.294273899999972 ], [ 51.582521500000034, 25.296335099999986 ], [ 51.578162599999978, 25.295995799999979 ], [ 51.581678099999969, 25.297018 ], [ 51.579799499999964, 25.299475699999959 ], [ 51.578332299999985, 25.299839400000032 ], [ 51.576869700000024, 25.299513 ], [ 51.57966, 25.299223499999965 ], [ 51.580566600000019, 25.297986799999958 ], [ 51.580008700000043, 25.298573600000015 ], [ 51.578158, 25.2976642 ], [ 51.577436500000026, 25.2987118 ], [ 51.5768609, 25.292747499999976 ], [ 51.573287400000012, 25.292604599999965 ], [ 51.571776100000022, 25.2950835 ], [ 51.568635400000041, 25.296259699999965 ], [ 51.569170199999967, 25.294087800000028 ], [ 51.564103599999974, 25.291184499999972 ], [ 51.5623693, 25.291648399999985 ], [ 51.564060599999969, 25.290920599999986 ], [ 51.561957300000024, 25.289525899999962 ], [ 51.562350400000042, 25.287988600000041 ], [ 51.5590351, 25.289413499999988 ], [ 51.561576200000026, 25.288230199999958 ], [ 51.56064, 25.286649199999975 ], [ 51.5555356, 25.286448 ], [ 51.5544773, 25.288579199999969 ], [ 51.553455899999967, 25.288446299999986 ], [ 51.554469100000041, 25.2867847 ], [ 51.552789399999973, 25.286932499999967 ], [ 51.552255300000013, 25.288635 ], [ 51.5517408, 25.286987100000044 ], [ 51.547543399999974, 25.291651399999967 ], [ 51.547541800000019, 25.2928143 ], [ 51.550903199999965, 25.29367059999997 ], [ 51.54822189999998, 25.293539599999967 ], [ 51.54790790000002, 25.295682099999958 ], [ 51.5520156, 25.297032400000038 ], [ 51.552482399999974, 25.298428900000033 ], [ 51.554854899999988, 25.294314300000028 ], [ 51.556487900000015, 25.29496710000004 ], [ 51.5513126, 25.304860399999981 ], [ 51.556118, 25.30651 ], [ 51.55863260000001, 25.3015286 ], [ 51.561382900000019, 25.302683499999986 ], [ 51.558420400000038, 25.3085543 ], [ 51.549854499999967, 25.304746399999964 ], [ 51.551915799999989, 25.299799600000025 ], [ 51.54811339999997, 25.297938100000014 ], [ 51.54613609999997, 25.301041899999962 ], [ 51.544591100000034, 25.300302299999963 ], [ 51.54567210000004, 25.297552399999987 ], [ 51.5443256, 25.297455400000043 ], [ 51.54268, 25.299621600000041 ], [ 51.540123799999982, 25.299329600000039 ], [ 51.539722099999963, 25.297795600000036 ], [ 51.542245300000012, 25.2982696 ], [ 51.543415400000015, 25.296170899999989 ], [ 51.539006099999959, 25.294637 ], [ 51.538293299999957, 25.291697499999962 ], [ 51.5342416, 25.291616900000044 ], [ 51.5346236, 25.293031400000018 ], [ 51.536967200000014, 25.292888800000032 ], [ 51.5370894, 25.294783899999981 ], [ 51.5348061, 25.295624900000021 ], [ 51.5316019, 25.295664899999956 ], [ 51.531210600000044, 25.294400599999975 ], [ 51.534518099999971, 25.29479 ], [ 51.533911699999976, 25.291649800000013 ], [ 51.528652600000044, 25.293830399999958 ], [ 51.528781400000042, 25.292927 ], [ 51.519674599999988, 25.299311300000035 ], [ 51.518274400000038, 25.3056368 ], [ 51.520921400000027, 25.3117135 ], [ 51.5268144, 25.3154804 ], [ 51.538750500000042, 25.3170733 ], [ 51.5377688, 25.319059799999962 ], [ 51.5393446, 25.319107099999968 ], [ 51.539027100000013, 25.323126800000026 ], [ 51.542182300000036, 25.325181500000035 ], [ 51.541299299999984, 25.323013 ], [ 51.542420700000044, 25.32534770000002 ], [ 51.537136199999964, 25.3323753 ], [ 51.525997199999985, 25.331892099999983 ], [ 51.522498, 25.335994100000011 ], [ 51.52341840000004, 25.34017960000002 ], [ 51.528893900000028, 25.343254499999976 ], [ 51.5302751, 25.346346 ], [ 51.5319358, 25.3465278 ], [ 51.531317, 25.348361600000032 ], [ 51.5327698, 25.348597600000019 ], [ 51.531823699999968, 25.35387 ], [ 51.526197899999978, 25.3541515 ], [ 51.526045, 25.356236 ], [ 51.5307721, 25.363060899999986 ], [ 51.5321043, 25.3636333 ], [ 51.533788199999975, 25.3621444 ], [ 51.531931600000014, 25.3640368 ], [ 51.527618099999984, 25.365920900000013 ], [ 51.518170100000027, 25.368308500000033 ], [ 51.508406299999962, 25.364210599999989 ], [ 51.505149599999974, 25.367058399999983 ], [ 51.5043256, 25.3699366 ], [ 51.518383600000014, 25.377653900000027 ], [ 51.541562099999972, 25.384537800000015 ], [ 51.533359899999972, 25.382738099999965 ], [ 51.5318435, 25.386992299999974 ], [ 51.532716500000028, 25.391075499999957 ], [ 51.5271761, 25.391467100000028 ], [ 51.527446399999988, 25.392963600000037 ], [ 51.525237900000043, 25.3934419 ], [ 51.5292156, 25.3947537 ], [ 51.5335329, 25.391581399999982 ], [ 51.539074700000043, 25.396587699999959 ], [ 51.535428, 25.401999600000011 ], [ 51.534290400000046, 25.4068707 ], [ 51.53712210000004, 25.4089929 ], [ 51.5219892, 25.409343899999989 ], [ 51.5193805, 25.410595499999985 ], [ 51.515075600000046, 25.409641900000043 ], [ 51.508735400000013, 25.418355199999962 ], [ 51.510693400000015, 25.424193500000033 ], [ 51.514767599999963, 25.425936199999985 ], [ 51.516355499999989, 25.4247201 ], [ 51.514497299999981, 25.41849140000004 ], [ 51.517162300000038, 25.4135948 ], [ 51.521829400000016, 25.411288899999981 ], [ 51.53100660000004, 25.411086099999988 ], [ 51.531215800000027, 25.419322499999971 ], [ 51.529802, 25.422376599999982 ], [ 51.528041899999963, 25.422172599999978 ], [ 51.527879899999974, 25.419110099999983 ], [ 51.525034099999964, 25.417409400000043 ], [ 51.522005899999968, 25.418363 ], [ 51.520598799999981, 25.421016100000035 ], [ 51.522813700000015, 25.425255 ], [ 51.529917299999973, 25.42578110000003 ], [ 51.533935800000016, 25.422671200000021 ], [ 51.533023600000035, 25.4117839 ], [ 51.538835100000021, 25.4105495 ], [ 51.538923100000019, 25.411793800000012 ], [ 51.535169400000036, 25.41211329999998 ], [ 51.5360277, 25.420524599999958 ], [ 51.538323699999985, 25.425077900000023 ], [ 51.5321879, 25.438667 ], [ 51.535705900000018, 25.439553500000031 ], [ 51.535384, 25.442305 ], [ 51.522798, 25.4424784 ], [ 51.519475799999967, 25.444807100000041 ], [ 51.515161100000014, 25.455542 ], [ 51.521125, 25.4555219 ], [ 51.5325262, 25.447462099999981 ], [ 51.5367533, 25.445625 ], [ 51.538736600000043, 25.447215700000022 ], [ 51.537271100000027, 25.445296300000017 ], [ 51.539329399999978, 25.442942699999968 ], [ 51.540506899999968, 25.444753799999983 ], [ 51.542449300000015, 25.4438191 ], [ 51.540762299999962, 25.4470039 ], [ 51.543367699999976, 25.44730680000001 ], [ 51.5444522, 25.449877 ], [ 51.540482299999979, 25.4479068 ], [ 51.5379257, 25.448847799999971 ], [ 51.5353236, 25.447442100000014 ], [ 51.532796399999981, 25.447762699999984 ], [ 51.5218496, 25.455452500000039 ], [ 51.518397, 25.456526199999971 ], [ 51.5153916, 25.460073799999957 ], [ 51.513536299999963, 25.4603835 ], [ 51.508597100000031, 25.4660793 ], [ 51.5113974, 25.469373800000014 ], [ 51.5057853, 25.47132970000002 ], [ 51.5059764, 25.472343699999985 ], [ 51.5090915, 25.473344600000022 ], [ 51.522010299999977, 25.479879700000016 ], [ 51.52538170000004, 25.480233499999979 ], [ 51.5284825, 25.479769300000029 ], [ 51.534236600000035, 25.4766485 ], [ 51.535501299999964, 25.477838200000033 ], [ 51.536739199999978, 25.477214300000014 ], [ 51.53623530000003, 25.477989500000028 ], [ 51.536867700000045, 25.47721890000004 ], [ 51.536579800000027, 25.476504 ], [ 51.536978300000044, 25.47710810000002 ], [ 51.536564299999988, 25.477938399999974 ], [ 51.5346077, 25.4785752 ], [ 51.5331091, 25.478075599999958 ], [ 51.527978599999969, 25.48001620000003 ], [ 51.525231400000038, 25.4803497 ], [ 51.523174600000033, 25.480215 ], [ 51.52182540000004, 25.479974699999971 ], [ 51.5196232, 25.479164099999959 ], [ 51.506832100000011, 25.472793399999979 ], [ 51.498674699999988, 25.476681199999959 ], [ 51.4973814, 25.4743255 ], [ 51.4931798, 25.474810199999961 ], [ 51.495547599999981, 25.472713 ], [ 51.491637099999984, 25.475037600000036 ], [ 51.488407899999963, 25.479851399999983 ], [ 51.491837699999977, 25.475455399999966 ], [ 51.489493700000011, 25.4803797 ], [ 51.491089299999956, 25.492934399999964 ], [ 51.484535199999989, 25.4997609 ], [ 51.477755900000041, 25.503370200000028 ], [ 51.474149299999972, 25.5137662 ], [ 51.480289300000045, 25.525719799999965 ], [ 51.483972399999963, 25.526835 ], [ 51.488492300000019, 25.538159199999985 ], [ 51.497434200000022, 25.5388958 ], [ 51.497852299999977, 25.545927499999962 ], [ 51.490974, 25.54989580000003 ], [ 51.4994285, 25.567472400000021 ], [ 51.494056399999963, 25.565891400000037 ], [ 51.489923799999978, 25.566641 ], [ 51.4900819, 25.570758200000018 ], [ 51.488113500000033, 25.57514 ], [ 51.488329599999972, 25.577976 ], [ 51.4964593, 25.578128500000016 ], [ 51.488269399999965, 25.578485100000034 ], [ 51.4911307, 25.5846527 ], [ 51.496804699999984, 25.583861 ], [ 51.49084950000001, 25.58491050000001 ], [ 51.491430600000044, 25.58825430000001 ], [ 51.48973120000003, 25.589032 ], [ 51.493041700000028, 25.600602 ], [ 51.4954694, 25.604196799999976 ], [ 51.498870600000032, 25.603026699999972 ], [ 51.5039927, 25.606226699999976 ], [ 51.514974500000029, 25.60722650000001 ], [ 51.517349399999979, 25.604918600000012 ], [ 51.514161299999984, 25.60821730000001 ], [ 51.518790700000039, 25.615182399999966 ], [ 51.528324019725233, 25.615035642630154 ], [ 51.534554200000024, 25.617746400000016 ], [ 51.539519100000042, 25.616779699999967 ], [ 51.5477155, 25.623876499999984 ], [ 51.5495853, 25.6319126 ], [ 51.548792400000018, 25.634366800000027 ], [ 51.551759700000041, 25.638700699999969 ], [ 51.553244200000037, 25.6384756 ], [ 51.5518258, 25.638738299999972 ], [ 51.552976800000025, 25.642079400000014 ], [ 51.551304, 25.649476099999976 ], [ 51.553038599999987, 25.655461699999979 ], [ 51.555022380525259, 25.655843849327272 ], [ 51.554900400000022, 25.659057699999973 ], [ 51.5493998, 25.659985 ], [ 51.552856099999985, 25.662656899999966 ], [ 51.549547399999959, 25.661777600000043 ], [ 51.5479464, 25.659598599999963 ], [ 51.545109300000014, 25.660124 ], [ 51.544343840915452, 25.661884293892165 ], [ 51.537125399999958, 25.661358099999973 ], [ 51.5344788, 25.664281 ], [ 51.536417594332818, 25.667477203288222 ], [ 51.5326517, 25.66840539999998 ], [ 51.5318101, 25.670724600000025 ], [ 51.533556, 25.676026300000018 ], [ 51.537798599999974, 25.6762353 ], [ 51.538903199999972, 25.6776985 ], [ 51.540539099999968, 25.6845074 ], [ 51.529228199999977, 25.684017499999964 ], [ 51.5294583, 25.68113930000003 ], [ 51.52714469999998, 25.680292899999987 ], [ 51.526776499999983, 25.685346399999961 ], [ 51.521200700000044, 25.686213699999957 ], [ 51.51912489999998, 25.684942799999963 ], [ 51.519838599999964, 25.687902200000043 ], [ 51.51737260000003, 25.685950300000012 ], [ 51.515062, 25.687020800000035 ], [ 51.517133100000024, 25.688077299999964 ], [ 51.515379200000034, 25.688012899999965 ], [ 51.5144074, 25.686512199999964 ], [ 51.509453500000014, 25.687108 ], [ 51.504656400000023, 25.690433400000042 ], [ 51.505401300000017, 25.692597 ], [ 51.5158639, 25.697709200000038 ], [ 51.5182149, 25.694059200000016 ], [ 51.520615799999966, 25.6972193 ], [ 51.5329921, 25.701424400000036 ], [ 51.537072400000014, 25.704289699999968 ], [ 51.543602799999974, 25.7036225 ], [ 51.54359580000002, 25.702078599999986 ], [ 51.54842, 25.701031 ], [ 51.551266299999988, 25.702307099999974 ], [ 51.552966, 25.701271199999972 ], [ 51.552695, 25.7041032 ], [ 51.555261100000024, 25.706152299999982 ], [ 51.5551042, 25.703064600000033 ], [ 51.5575204, 25.703312799999964 ], [ 51.558648299999973, 25.701506900000023 ], [ 51.554673299999976, 25.701907699999968 ], [ 51.553380899999979, 25.698953499999963 ], [ 51.560605199999976, 25.694808099999985 ], [ 51.56255359999998, 25.686308100000041 ], [ 51.557714499999982, 25.6840104 ], [ 51.5560165, 25.685303699999981 ], [ 51.558018900000036, 25.688384200000044 ], [ 51.556882299999963, 25.688259500000029 ], [ 51.548627300000035, 25.684302199999983 ], [ 51.547762499999983, 25.681474599999973 ], [ 51.546348200000025, 25.682766600000026 ], [ 51.546735900000037, 25.680773499999962 ], [ 51.560862799999974, 25.681568500000015 ], [ 51.561184699999963, 25.678458199999973 ], [ 51.561027199999984, 25.6816038 ], [ 51.567071100000014, 25.680881800000041 ], [ 51.5695773, 25.678554599999956 ], [ 51.5701162, 25.6715121 ], [ 51.5709353, 25.677773399999978 ], [ 51.57297, 25.677773100000042 ], [ 51.5732873, 25.6766123 ], [ 51.571692799999965, 25.676134199999975 ], [ 51.573618300000035, 25.6764243 ], [ 51.573678899999983, 25.6751984 ], [ 51.573724799999965, 25.6764791 ], [ 51.5756048, 25.676259599999959 ], [ 51.576541699999979, 25.674421700000035 ], [ 51.576263, 25.677285799999957 ], [ 51.58021279999997, 25.679514100000031 ], [ 51.5813329, 25.677279 ], [ 51.5803131, 25.6764158 ], [ 51.58194849999996, 25.676325099999961 ], [ 51.5804226, 25.679503400000034 ], [ 51.582509600000023, 25.689979 ], [ 51.586656500000039, 25.690306799999959 ], [ 51.581848699999966, 25.6901656 ], [ 51.581695, 25.692399199999979 ], [ 51.585567800000021, 25.692791 ], [ 51.581806600000036, 25.692558 ], [ 51.582080200000021, 25.697443 ], [ 51.587171800000043, 25.701261699999986 ], [ 51.589983299999965, 25.70059489999997 ], [ 51.5872635, 25.701395599999962 ], [ 51.587574699999983, 25.704045099999981 ], [ 51.5905592, 25.709462500000043 ], [ 51.5917785, 25.710081899999956 ], [ 51.593043300000019, 25.708747599999956 ], [ 51.591820600000013, 25.711246699999965 ], [ 51.595235899999977, 25.720051199999968 ], [ 51.589721200000035, 25.726609099999983 ], [ 51.587252, 25.735643900000035 ], [ 51.576656200000038, 25.739917499999962 ], [ 51.575551500000024, 25.73459959999996 ], [ 51.57261589999996, 25.735118299999979 ], [ 51.569883700000027, 25.731972800000044 ], [ 51.570388599999973, 25.725923 ], [ 51.5673338, 25.728822900000011 ], [ 51.550729100000034, 25.734071300000036 ], [ 51.547952599999988, 25.7389895 ], [ 51.5491185, 25.738413500000043 ], [ 51.549009300000023, 25.739875200000014 ], [ 51.540284, 25.739804799999963 ], [ 51.5375713, 25.749654899999971 ], [ 51.539115799999976, 25.748624900000014 ], [ 51.539424699999955, 25.750462700000018 ], [ 51.540676, 25.74704329999998 ], [ 51.547558399999971, 25.7447699 ], [ 51.547484299999965, 25.742268299999957 ], [ 51.5505945, 25.7414273 ], [ 51.561843500000023, 25.74322790000004 ], [ 51.56276589999996, 25.761711700000042 ], [ 51.568627900000038, 25.769152 ], [ 51.571476099999977, 25.7704276 ], [ 51.571913099999989, 25.7727421 ], [ 51.568085800000041, 25.774686699999968 ], [ 51.565616900000045, 25.773111600000028 ], [ 51.566095699999956, 25.774566300000043 ], [ 51.564083, 25.769684499999975 ], [ 51.561516599999976, 25.767892899999975 ], [ 51.558968299999982, 25.76996149999998 ], [ 51.562972299999984, 25.775221199999962 ], [ 51.566957500000029, 25.7764926 ], [ 51.5766213, 25.776454599999962 ], [ 51.577184100000018, 25.7752947 ], [ 51.579188600000045, 25.77837509999997 ], [ 51.5806061, 25.7775973 ], [ 51.57976470000002, 25.77991669999998 ], [ 51.580897799999981, 25.779140300000044 ], [ 51.582044800000027, 25.781194600000021 ], [ 51.584460399999962, 25.7811847 ], [ 51.586354, 25.790441799999972 ], [ 51.587779599999969, 25.7913363 ], [ 51.59119470000001, 25.792094600000034 ], [ 51.592038, 25.790161499999961 ], [ 51.5928983, 25.791702 ], [ 51.5951686, 25.790920699999983 ], [ 51.594561699999971, 25.7832027 ], [ 51.59568830000002, 25.781139199999966 ], [ 51.5939458, 25.773683099999975 ], [ 51.596519200000024, 25.776760799999984 ], [ 51.597069900000022, 25.801721699999977 ], [ 51.59023830000001, 25.8151218 ], [ 51.588564100000042, 25.821562199999967 ], [ 51.588929900000025, 25.8349066 ], [ 51.585296500000041, 25.850913100000014 ], [ 51.585944900000044, 25.852886100000013 ], [ 51.588914299999978, 25.852412399999988 ], [ 51.589094499999966, 25.853452299999965 ], [ 51.5895286, 25.852395600000019 ], [ 51.589267, 25.853636099999985 ], [ 51.585315700000031, 25.8530009 ], [ 51.584527, 25.856273200000043 ], [ 51.585923599999973, 25.856813399999975 ], [ 51.584296399999985, 25.856445900000033 ], [ 51.58516870000004, 25.857234099999967 ], [ 51.583423599999975, 25.861058300000014 ], [ 51.662040500000018, 25.8986944 ], [ 51.65657790000003, 25.905553399999967 ], [ 51.658939300000014, 25.908046899999956 ], [ 51.656239199999987, 25.906146199999988 ], [ 51.652786300000017, 25.909564500000023 ], [ 51.661526700000046, 25.898848200000021 ], [ 51.6576251, 25.896927099999964 ], [ 51.656161300000022, 25.898811900000037 ], [ 51.6509987, 25.896362399999958 ], [ 51.647083300000041, 25.902585499999983 ], [ 51.6489314, 25.899353 ], [ 51.6467779, 25.898286700000014 ], [ 51.6440075, 25.897076599999988 ], [ 51.642017799999962, 25.900162100000021 ], [ 51.6456926, 25.893820200000025 ], [ 51.643606400000039, 25.892838299999962 ], [ 51.641795200000018, 25.895997 ], [ 51.642775600000043, 25.893732 ], [ 51.63786, 25.890111400000023 ], [ 51.6353984, 25.893953400000033 ], [ 51.631746, 25.891776599999957 ], [ 51.634066400000023, 25.885987799999985 ], [ 51.61868920000002, 25.8786251 ], [ 51.617721599999989, 25.880243499999963 ], [ 51.615616299999964, 25.879215299999977 ], [ 51.616604500000015, 25.877676099999988 ], [ 51.583583, 25.861875699999967 ], [ 51.580063699999975, 25.866613500000021 ], [ 51.5758507, 25.877696100000044 ], [ 51.5748674, 25.8902293 ], [ 51.563363700000039, 25.8896195 ], [ 51.5647212, 25.8909795 ], [ 51.57477530000002, 25.891342800000036 ], [ 51.563416, 25.89136119999996 ], [ 51.600733500000018, 25.892299699999985 ], [ 51.633135, 25.906973300000033 ], [ 51.635217799999985, 25.903328399999989 ], [ 51.636164599999987, 25.9037676 ], [ 51.631054300000024, 25.912742499999982 ], [ 51.63010520000001, 25.9122705 ], [ 51.632140700000029, 25.908685599999956 ], [ 51.622966199999965, 25.904237900000012 ], [ 51.619129899999983, 25.910769900000016 ], [ 51.622327499999962, 25.904047100000035 ], [ 51.600545199999978, 25.893354699999968 ], [ 51.586420699999977, 25.89352410000004 ], [ 51.5930732, 25.904134100000039 ], [ 51.592152899999974, 25.9056664 ], [ 51.593359499999977, 25.90635830000004 ], [ 51.5903756, 25.9089792 ], [ 51.6104265, 25.917497500000039 ], [ 51.613076499999963, 25.91981820000003 ], [ 51.6165635, 25.9145429 ], [ 51.613688200000041, 25.9200712 ], [ 51.6176005, 25.921990900000033 ], [ 51.619133099999978, 25.919035 ], [ 51.618300199999986, 25.9222878 ], [ 51.622697400000014, 25.924401199999977 ], [ 51.632564900000041, 25.923215 ], [ 51.636837, 25.916688199999957 ], [ 51.63286, 25.923687800000014 ], [ 51.6217483, 25.9251154 ], [ 51.618426699999972, 25.923500399999963 ], [ 51.618850300000027, 25.925651699999971 ], [ 51.6174169, 25.923075499999978 ], [ 51.6158056, 25.92569010000004 ], [ 51.616385600000022, 25.9227987 ], [ 51.614393500000041, 25.921842 ], [ 51.613231, 25.924377200000034 ], [ 51.614009, 25.921674 ], [ 51.6118994, 25.920697300000025 ], [ 51.609648800000038, 25.922841200000043 ], [ 51.611155, 25.920362699999963 ], [ 51.59802310000002, 25.914161499999974 ], [ 51.593594399999965, 25.919770299999975 ], [ 51.587336800000017, 25.915917200000024 ], [ 51.58464309999998, 25.918783799999975 ], [ 51.593429800000024, 25.9252645 ], [ 51.5962773, 25.921499499999964 ], [ 51.59760040000004, 25.9223619 ], [ 51.5966026, 25.9236491 ], [ 51.600014, 25.9259988 ], [ 51.603897599999982, 25.921973 ], [ 51.603949600000021, 25.923607699999959 ], [ 51.606295599999974, 25.924660400000018 ], [ 51.602734600000034, 25.929119 ], [ 51.5928521, 25.926272 ], [ 51.591913200000036, 25.9271827 ], [ 51.590286099999972, 25.9255169 ], [ 51.589253, 25.926546500000022 ], [ 51.596818700000021, 25.933758200000042 ], [ 51.599089, 25.93160780000002 ], [ 51.5999603, 25.93228669999997 ], [ 51.597115299999963, 25.934110399999962 ], [ 51.60091840000004, 25.937082400000019 ], [ 51.619322700000033, 25.930871799999963 ], [ 51.619839499999983, 25.929387 ], [ 51.6210944, 25.930174700000016 ], [ 51.617925200000045, 25.93275210000002 ], [ 51.617028, 25.931992399999956 ], [ 51.602056599999976, 25.9382167 ], [ 51.609722800000036, 25.939400399999965 ], [ 51.613329, 25.9355428 ], [ 51.6141471, 25.9363425 ], [ 51.610623699999969, 25.939709300000032 ], [ 51.626073400000017, 25.941799499999959 ], [ 51.642011499999974, 25.933343099999981 ], [ 51.639589500000035, 25.929340099999973 ], [ 51.642474199999974, 25.9329933 ], [ 51.651725700000014, 25.9276433 ], [ 51.6580493, 25.926483499999961 ], [ 51.6513014, 25.928342899999976 ], [ 51.62687159999998, 25.942596199999976 ], [ 51.622387300000028, 25.9428648 ], [ 51.5967893, 25.939305099999984 ], [ 51.574907600000039, 25.921591600000035 ], [ 51.573377700000023, 25.918883799999989 ], [ 51.5710587, 25.918966299999976 ], [ 51.550975900000026, 25.9274167 ], [ 51.552514100000025, 25.9318674 ], [ 51.547082799999963, 25.9330836 ], [ 51.54986109999998, 25.940177699999975 ], [ 51.547508, 25.935216299999983 ], [ 51.5456599, 25.928695099999985 ], [ 51.537957300000045, 25.932205099999969 ], [ 51.5456544, 25.940473400000016 ], [ 51.550008199999986, 25.942835200000033 ], [ 51.5456845, 25.940828900000032 ], [ 51.537839499999983, 25.932351 ], [ 51.515977200000037, 25.949492800000037 ], [ 51.505175100000045, 25.952876499999963 ], [ 51.496477900000038, 25.953788500000016 ], [ 51.496364399999969, 25.9549422 ], [ 51.49580810000004, 25.953802799999956 ], [ 51.487995, 25.953954 ], [ 51.487651299999982, 25.958943599999959 ], [ 51.486750599999972, 25.9541392 ], [ 51.480774300000029, 25.953465899999969 ], [ 51.480311600000029, 25.954679500000019 ], [ 51.48056710000003, 25.953594200000015 ], [ 51.4749763, 25.952199099999959 ], [ 51.474796300000037, 25.954129499999986 ], [ 51.473127200000043, 25.954641100000039 ], [ 51.47421970000002, 25.954225 ], [ 51.47249, 25.953597500000022 ], [ 51.472784600000033, 25.951712899999965 ], [ 51.455702900000041, 25.948658800000043 ], [ 51.460359899999986, 25.9521319 ], [ 51.458647699999979, 25.956282499999958 ], [ 51.4565654, 25.9566513 ], [ 51.4583945, 25.956135699999979 ], [ 51.459729599999967, 25.9520161 ], [ 51.453316899999976, 25.948245300000025 ], [ 51.45085620000004, 25.9484469 ], [ 51.453770600000034, 25.9505539 ], [ 51.45148930000002, 25.950161799999968 ], [ 51.450239, 25.947848200000031 ], [ 51.440600100000012, 25.948285599999984 ], [ 51.440045400000031, 25.950406499999964 ], [ 51.4390241, 25.948640899999983 ], [ 51.437483399999969, 25.948889300000019 ], [ 51.433788399999955, 25.950390100000028 ], [ 51.434966299999985, 25.952047600000036 ], [ 51.432781799999979, 25.9503993 ], [ 51.417780199999974, 25.9567756 ], [ 51.40427470000003, 25.965220800000019 ], [ 51.400621600000015, 25.970445699999964 ], [ 51.398907799999968, 26.0108541 ], [ 51.389245200000019, 26.017056700000015 ], [ 51.380427499999989, 26.020683100000038 ], [ 51.375888300000028, 26.026356699999983 ], [ 51.373895299999973, 26.026619 ], [ 51.3731892, 26.028679699999987 ], [ 51.3744731, 26.029191100000023 ], [ 51.3747523, 26.027389 ], [ 51.375612600000039, 26.029188100000042 ], [ 51.3773134, 26.026610099999989 ], [ 51.381122799999964, 26.0260305 ], [ 51.382485099999975, 26.023928 ], [ 51.381849699999982, 26.026168599999963 ], [ 51.370363500000046, 26.035892700000026 ], [ 51.35788120000003, 26.052908900000013 ], [ 51.356476100000037, 26.059346 ], [ 51.3573945, 26.065336600000041 ], [ 51.361229, 26.06488430000001 ], [ 51.3588673, 26.0652975 ], [ 51.361394799999957, 26.066210699999978 ], [ 51.362320199999964, 26.06481060000004 ], [ 51.364836100000034, 26.0656505 ], [ 51.365005600000025, 26.064319800000021 ], [ 51.365499600000042, 26.066932099999981 ], [ 51.358273499999981, 26.066995 ], [ 51.35764620000004, 26.0693797 ], [ 51.360272900000034, 26.07523250000002 ], [ 51.357515699999986, 26.083969899999978 ], [ 51.360950699999982, 26.099211300000022 ], [ 51.3588984, 26.103223900000025 ], [ 51.341384200000014, 26.112552499999961 ], [ 51.335318699999974, 26.118149499999962 ], [ 51.309857900000011, 26.133303 ], [ 51.277264700000011, 26.1417938 ], [ 51.269700799999981, 26.146991199999977 ], [ 51.272201, 26.147027100000017 ], [ 51.26251570000003, 26.151162399999958 ], [ 51.26295040000003, 26.15450720000004 ], [ 51.265658099999975, 26.153730199999966 ], [ 51.267373599999985, 26.155785799999961 ], [ 51.2619572, 26.156438599999973 ], [ 51.259102599999984, 26.155028800000032 ], [ 51.260557, 26.1534805 ], [ 51.251982199999965, 26.159029899999972 ] ] ], [ [ [ 51.261985, 26.168920100000012 ], [ 51.259266300000029, 26.164807700000011 ], [ 51.260263, 26.164033900000025 ], [ 51.259981400000044, 26.1655784 ], [ 51.262550900000015, 26.166860400000033 ], [ 51.264545400000017, 26.166084699999978 ], [ 51.273188, 26.1570142 ], [ 51.269660099999989, 26.158097600000016 ], [ 51.270502699999987, 26.152434400000043 ], [ 51.272499299999986, 26.152688 ], [ 51.2716461, 26.153719 ], [ 51.274636100000038, 26.152169200000039 ], [ 51.273216399999988, 26.15474550000004 ], [ 51.274786400000039, 26.1552571 ], [ 51.275078799999982, 26.158344600000024 ], [ 51.2809068, 26.151127800000026 ], [ 51.281611899999987, 26.147651800000013 ], [ 51.284744199999984, 26.145973399999964 ], [ 51.285033, 26.147516800000034 ], [ 51.288159799999974, 26.143521400000033 ], [ 51.2927147, 26.140681399999973 ], [ 51.29698970000004, 26.140029799999972 ], [ 51.3014, 26.136675199999967 ], [ 51.29955310000004, 26.138995199999989 ], [ 51.2918635, 26.1423564 ], [ 51.290443500000016, 26.144675400000036 ], [ 51.28190340000004, 26.150353900000031 ], [ 51.275789399999979, 26.157571199999982 ], [ 51.275652800000046, 26.159887599999973 ], [ 51.269103, 26.163760200000027 ], [ 51.269108199999977, 26.166076199999985 ], [ 51.261985, 26.168920100000012 ] ] ], [ [ [ 51.216372300000032, 26.1781312 ], [ 51.214662599999969, 26.179035 ], [ 51.2140983, 26.182381300000021 ], [ 51.212103200000037, 26.18315620000001 ], [ 51.211669300000018, 26.180068699999989 ], [ 51.214233800000017, 26.178778199999972 ], [ 51.21565410000003, 26.175688 ], [ 51.215073, 26.169769899999981 ], [ 51.218919899999968, 26.1678336 ], [ 51.22049249999997, 26.170276399999967 ], [ 51.218785300000022, 26.1723378 ], [ 51.2217842, 26.174392 ], [ 51.223636, 26.173617099999976 ], [ 51.220930399999965, 26.175422699999981 ], [ 51.2266384, 26.177472600000037 ], [ 51.238053099999966, 26.1805423 ], [ 51.2478852, 26.1771802 ], [ 51.24005079999997, 26.1811819 ], [ 51.216372300000032, 26.1781312 ] ] ] ] } }
]
}


def parse_border_file(file_content):
    """Parse border coordinates from a text file or GeoJSON.

    Supports formats:
    1. GeoJSON FeatureCollection: {"type": "FeatureCollection", "features": [...]}
    2. GeoJSON Feature: {"type": "Feature", "geometry": {...}}
    3. GeoJSON Polygon: {"type": "Polygon", "coordinates": [[[lon, lat], ...]]}
    4. Simple text format: One coordinate per line as "lon, lat" or "lon lat"
    """
    content = file_content.strip()

    if content.startswith('{'):
        try:
            data = json.loads(content)

            if data.get('type') == 'FeatureCollection':
                for feature in data.get('features', []):
                    geom = feature.get('geometry', {})
                    if geom.get('type') in ['Polygon', 'MultiPolygon']:
                        return geom

            elif data.get('type') == 'Feature':
                geom = data.get('geometry', {})
                if geom.get('type') in ['Polygon', 'MultiPolygon']:
                    return geom

            elif data.get('type') in ['Polygon', 'MultiPolygon']:
                return data

            elif 'coordinates' in data:
                return {"type": "Polygon", "coordinates": data['coordinates']}

            elif isinstance(data, list):
                return {"type": "Polygon", "coordinates": [data]}

        except json.JSONDecodeError:
            pass

    coords = []
    lines = content.split('\n')
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue

        parts = re.split(r'[,\s\t]+', line)
        if len(parts) >= 2:
            try:
                lon = float(parts[0])
                lat = float(parts[1])
                coords.append([lon, lat])
            except ValueError:
                continue

    if len(coords) >= 3:
        if coords[0] != coords[-1]:
            coords.append(coords[0])
        return {"type": "Polygon", "coordinates": [coords]}

    return None

def get_shapely_polygon(border_geojson):
    """Convert border GeoJSON to Shapely polygon."""
    try:
        return shape(border_geojson)
    except Exception:
        coords = border_geojson.get("coordinates", [[]])[0]
        return Polygon(coords)

SAVED_BORDER_FILE = "saved_border.json"

def save_border_to_file(border_data):
    """Save custom border to file for persistence."""
    try:
        with open(SAVED_BORDER_FILE, 'w') as f:
            json.dump(border_data, f)
        return True
    except Exception:
        return False

def load_border_from_file():
    """Load saved border from file if it exists and is valid."""
    if not os.path.exists(SAVED_BORDER_FILE):
        return None
    try:
        with open(SAVED_BORDER_FILE, 'r') as f:
            data = json.load(f)
        if data and isinstance(data, dict) and 'type' in data and 'coordinates' in data:
            poly = get_shapely_polygon(data)
            if poly and not poly.is_empty:
                return data
        delete_saved_border()
        return None
    except (json.JSONDecodeError, IOError):
        delete_saved_border()
        return None
    except Exception:
        delete_saved_border()
        return None

def delete_saved_border():
    """Delete the saved border file."""
    try:
        if os.path.exists(SAVED_BORDER_FILE):
            os.remove(SAVED_BORDER_FILE)
            return True
    except Exception:
        pass
    return False

def get_current_border():
    """Get the current border from session state, saved file, or default."""
    if 'custom_border' in st.session_state and st.session_state.custom_border:
        return st.session_state.custom_border
    saved = load_border_from_file()
    if saved:
        st.session_state.custom_border = saved
        return saved
    return DEFAULT_BORDER

def point_in_polygon(x, y, polygon):
    """Check if point (x, y) is inside polygon using ray casting."""
    n = len(polygon)
    inside = False
    p1x, p1y = polygon[0]
    for i in range(1, n + 1):
        p2x, p2y = polygon[i % n]
        if y > min(p1y, p2y):
            if y <= max(p1y, p2y):
                if x <= max(p1x, p2x):
                    if p1y != p2y:
                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x
                    if p1x == p2x or x <= xinters:
                        inside = not inside
        p1x, p1y = p2x, p2y
    return inside

def idw_interpolation(xi, yi, zi, grid_x, grid_y, power=2.5, k_neighbors=12):
    """Inverse Distance Weighting interpolation with improved quality.

    Args:
        xi, yi: Data point coordinates
        zi: Data point values
        grid_x, grid_y: Grid coordinates for interpolation
        power: Distance decay power (higher = more local influence, 2-3 recommended)
        k_neighbors: Number of nearest neighbors to consider (8-12 recommended)
    """
    if len(xi) == 0:
        return np.zeros_like(grid_x)

    xi = np.asarray(xi, dtype=float)
    yi = np.asarray(yi, dtype=float)
    zi = np.asarray(zi, dtype=float)

    valid_mask = np.isfinite(xi) & np.isfinite(yi) & np.isfinite(zi)
    xi = xi[valid_mask]
    yi = yi[valid_mask]
    zi = zi[valid_mask]

    if len(xi) == 0:
        return np.zeros_like(grid_x)

    tree = cKDTree(np.c_[xi, yi])
    grid_points = np.c_[grid_x.ravel(), grid_y.ravel()]

    if not np.all(np.isfinite(grid_points)):
        grid_points = np.nan_to_num(grid_points, nan=0.0, posinf=0.0, neginf=0.0)

    k = min(k_neighbors, len(xi))
    distances, indices = tree.query(grid_points, k=k)

    if k == 1:
        distances = distances.reshape(-1, 1)
        indices = indices.reshape(-1, 1)

    distances = np.maximum(distances, 1e-10)
    weights = 1 / distances**power
    weights /= weights.sum(axis=1)[:, None]

    zi_grid = np.sum(weights * zi[indices], axis=1)
    return zi_grid.reshape(grid_x.shape)

def rbf_interpolation(xi, yi, zi, grid_x, grid_y, smooth=0.1):
    """Radial Basis Function interpolation for smooth, natural-looking maps.
    
    Args:
        xi, yi: Data point coordinates
        zi: Data point values
        grid_x, grid_y: Grid coordinates for interpolation
        smooth: Smoothing factor (higher = smoother but less accurate)
    """
    from scipy.interpolate import RBFInterpolator
    from scipy.ndimage import gaussian_filter
    
    if len(xi) == 0:
        return np.zeros_like(grid_x)
    
    xi = np.asarray(xi, dtype=float)
    yi = np.asarray(yi, dtype=float)
    zi = np.asarray(zi, dtype=float)
    
    valid_mask = np.isfinite(xi) & np.isfinite(yi) & np.isfinite(zi)
    xi = xi[valid_mask]
    yi = yi[valid_mask]
    zi = zi[valid_mask]
    
    if len(xi) < 3:
        return np.zeros_like(grid_x)
    
    try:
        points = np.column_stack([xi, yi])
        rbf = RBFInterpolator(points, zi, kernel='thin_plate_spline', smoothing=smooth)
        
        grid_points = np.column_stack([grid_x.ravel(), grid_y.ravel()])
        zi_grid = rbf(grid_points).reshape(grid_x.shape)
        
        zi_grid = gaussian_filter(zi_grid, sigma=1.5)
        
        return zi_grid
    except Exception:
        return idw_interpolation(xi, yi, zi, grid_x, grid_y, power=2.0, k_neighbors=min(15, len(xi)))

def create_interpolation_map_pydeck(wells_df, ro_df, data_type='ec', classes=None, border=None):
    """Create WebGL-accelerated interpolation map using PyDeck for EC or pH values."""
    all_coords = []
    all_values = []

    if data_type == 'ec':
        value_col_wells = 'well water salinity'
        value_col_ro = 'ro water salinity'
    else:
        value_col_wells = 'well ph'
        value_col_ro = 'ro ph'

    if wells_df is not None and len(wells_df) > 0:
        for _, row in wells_df.iterrows():
            lat, lon = parse_coordinates(row.get('well google coordinates', ''))
            val = pd.to_numeric(row.get(value_col_wells, np.nan), errors='coerce')
            if lat is not None and lon is not None and not pd.isna(val) and np.isfinite(val):
                all_coords.append([lon, lat])
                all_values.append(val)

    if ro_df is not None and len(ro_df) > 0:
        for _, row in ro_df.iterrows():
            lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
            val = pd.to_numeric(row.get(value_col_ro, np.nan), errors='coerce')
            if lat is not None and lon is not None and not pd.isna(val) and np.isfinite(val):
                all_coords.append([lon, lat])
                all_values.append(val)

    if len(all_coords) < 3:
        return None, None, None

    coords = np.array(all_coords)
    values = np.array(all_values)

    current_border = border if border else get_current_border()
    border_poly = current_border["coordinates"][0]
    lon_min = min(p[0] for p in border_poly)
    lon_max = max(p[0] for p in border_poly)
    lat_min = min(p[1] for p in border_poly)
    lat_max = max(p[1] for p in border_poly)

    center_lat = (lat_min + lat_max) / 2
    center_lon = (lon_min + lon_max) / 2

    resolution = 150
    grid_lon = np.linspace(lon_min, lon_max, resolution)
    grid_lat = np.linspace(lat_min, lat_max, resolution)
    grid_x, grid_y = np.meshgrid(grid_lon, grid_lat)

    k_neighbors = min(12, len(values))
    zi_grid = idw_interpolation(coords[:, 0], coords[:, 1], values, grid_x, grid_y, power=2.5, k_neighbors=k_neighbors)

    grid_data = []
    val_min = values.min()
    val_max = values.max()
    val_range = val_max - val_min + 1e-10

    for i in range(resolution):
        for j in range(resolution):
            lon_pt = grid_x[i, j]
            lat_pt = grid_y[i, j]
            if point_in_polygon(lon_pt, lat_pt, border_poly):
                interpolated_val = zi_grid[i, j]
                normalized_val = (interpolated_val - val_min) / val_range

                if classes:
                    r, g, b = 0, 0, 255
                    colors_rgb = [
                        (0, 0, 255),
                        (0, 255, 0),
                        (255, 255, 0),
                        (255, 165, 0),
                        (255, 0, 0)
                    ]
                    for idx, (threshold, _) in enumerate(classes):
                        if interpolated_val <= threshold:
                            r, g, b = colors_rgb[min(idx, len(colors_rgb) - 1)]
                            break
                        r, g, b = colors_rgb[min(idx + 1, len(colors_rgb) - 1)]
                else:
                    if normalized_val < 0.2:
                        r, g, b = 0, 0, 255
                    elif normalized_val < 0.4:
                        r, g, b = 0, 255, 255
                    elif normalized_val < 0.6:
                        r, g, b = 0, 255, 0
                    elif normalized_val < 0.8:
                        r, g, b = 255, 255, 0
                    else:
                        r, g, b = 255, 0, 0

                grid_data.append({
                    'lon': lon_pt,
                    'lat': lat_pt,
                    'value': interpolated_val,
                    'normalized': normalized_val,
                    'r': r,
                    'g': g,
                    'b': b
                })

    grid_df = pd.DataFrame(grid_data)

    point_data = []
    for i, (lon, lat) in enumerate(coords):
        point_data.append({
            'lon': lon,
            'lat': lat,
            'value': values[i],
            'label': f"{'EC' if data_type == 'ec' else 'pH'}: {values[i]:.2f}"
        })
    points_df = pd.DataFrame(point_data)

    border_coords = [[p[0], p[1]] for p in border_poly]
    border_data = pd.DataFrame([{'path': border_coords}])

    grid_layer = pdk.Layer(
        'ScatterplotLayer',
        data=grid_df,
        get_position='[lon, lat]',
        get_fill_color='[r, g, b, 180]',
        get_radius=800,
        pickable=False,
    )

    points_layer = pdk.Layer(
        'ScatterplotLayer',
        data=points_df,
        get_position='[lon, lat]',
        get_fill_color='[255, 255, 255, 230]',
        get_line_color='[0, 0, 0, 255]',
        get_radius=1500,
        pickable=True,
        stroked=True,
        line_width_min_pixels=2,
    )

    border_layer = pdk.Layer(
        'PathLayer',
        data=border_data,
        get_path='path',
        get_color='[0, 0, 139, 255]',
        width_min_pixels=3,
        pickable=False,
    )

    view_state = pdk.ViewState(
        latitude=center_lat,
        longitude=center_lon,
        zoom=7.5,
        pitch=0,
    )

    deck = pdk.Deck(
        layers=[grid_layer, border_layer, points_layer],
        initial_view_state=view_state,
        map_style='mapbox://styles/mapbox/satellite-streets-v12',
        tooltip={'text': '{label}'}
    )

    return deck, classes, data_type

def create_interpolation_map(wells_df, ro_df, data_type='ec', classes=None, border=None):
    """Create interpolation map for EC or pH values using Folium (fallback)."""
    all_coords = []
    all_values = []

    if data_type == 'ec':
        value_col_wells = 'well water salinity'
        value_col_ro = 'ro water salinity'
    else:
        value_col_wells = 'well ph'
        value_col_ro = 'ro ph'

    if wells_df is not None and len(wells_df) > 0:
        for _, row in wells_df.iterrows():
            lat, lon = parse_coordinates(row.get('well google coordinates', ''))
            val = pd.to_numeric(row.get(value_col_wells, np.nan), errors='coerce')
            if lat is not None and lon is not None and not pd.isna(val) and np.isfinite(val):
                all_coords.append([lon, lat])
                all_values.append(val)

    if ro_df is not None and len(ro_df) > 0:
        for _, row in ro_df.iterrows():
            lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
            val = pd.to_numeric(row.get(value_col_ro, np.nan), errors='coerce')
            if lat is not None and lon is not None and not pd.isna(val) and np.isfinite(val):
                all_coords.append([lon, lat])
                all_values.append(val)

    if len(all_coords) < 3:
        return None

    coords = np.array(all_coords)
    values = np.array(all_values)

    current_border = border if border else get_current_border()
    border_poly = current_border["coordinates"][0]
    lon_min = min(p[0] for p in border_poly)
    lon_max = max(p[0] for p in border_poly)
    lat_min = min(p[1] for p in border_poly)
    lat_max = max(p[1] for p in border_poly)

    center_lat = (lat_min + lat_max) / 2
    center_lon = (lon_min + lon_max) / 2

    m = folium.Map(location=[center_lat, center_lon], zoom_start=8, tiles=None)

    folium.TileLayer(
        tiles='https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
        attr='Google',
        name='Google Satellite Hybrid',
        overlay=False,
        control=True
    ).add_to(m)

    resolution = 100
    grid_lon = np.linspace(lon_min, lon_max, resolution)
    grid_lat = np.linspace(lat_min, lat_max, resolution)
    grid_x, grid_y = np.meshgrid(grid_lon, grid_lat)

    k_neighbors = min(12, len(values))
    zi_grid = idw_interpolation(coords[:, 0], coords[:, 1], values, grid_x, grid_y, power=2.5, k_neighbors=k_neighbors)

    heat_data = []
    for i in range(resolution):
        for j in range(resolution):
            lon_pt = grid_x[i, j]
            lat_pt = grid_y[i, j]
            if point_in_polygon(lon_pt, lat_pt, border_poly):
                normalized_val = (zi_grid[i, j] - values.min()) / (values.max() - values.min() + 1e-10)
                heat_data.append([lat_pt, lon_pt, normalized_val])

    if classes and len(classes) > 0:
        gradient = {}
        colors = ['#0000FF', '#00FF00', '#FFFF00', '#FFA500', '#FF0000']
        for idx, (threshold, _) in enumerate(classes):
            norm_threshold = (threshold - values.min()) / (values.max() - values.min() + 1e-10)
            norm_threshold = max(0.01, min(0.99, norm_threshold))
            color_idx = min(idx, len(colors) - 1)
            gradient[norm_threshold] = colors[color_idx]
    else:
        gradient = {0.2: 'blue', 0.4: 'cyan', 0.6: 'lime', 0.8: 'yellow', 1.0: 'red'}

    HeatMap(
        heat_data,
        min_opacity=0.5,
        max_zoom=18,
        radius=15,
        blur=20,
        gradient=gradient
    ).add_to(m)

    folium.GeoJson(
        {"type": "Feature", "geometry": current_border, "properties": {}},
        style_function=lambda x: {'fillColor': 'transparent', 'color': 'darkblue', 'weight': 3}
    ).add_to(m)

    for i, (lon, lat) in enumerate(coords):
        folium.CircleMarker(
            location=[lat, lon],
            radius=6,
            popup=f"{'EC' if data_type == 'ec' else 'pH'}: {values[i]:.2f}",
            color='black',
            fill=True,
            fill_color='white',
            fill_opacity=0.8
        ).add_to(m)

    if classes:
        legend_items = ""
        colors = ['blue', 'green', 'yellow', 'orange', 'red']
        for idx, (threshold, label) in enumerate(classes):
            color = colors[min(idx, len(colors) - 1)]
            legend_items += f'<p><span style="background:{color};width:20px;height:10px;display:inline-block;"></span> {label}</p>'

        legend_html = f'''
        <div style="position: fixed; bottom: 50px; right: 50px; z-index: 1000; background-color: white; 
                    padding: 10px; border-radius: 5px; border: 2px solid grey;">
            <p><strong>{'EC (Salinity)' if data_type == 'ec' else 'pH'} Classes</strong></p>
            {legend_items}
        </div>
        '''
        m.get_root().html.add_child(folium.Element(legend_html))

    folium.LayerControl().add_to(m)

    return m

def create_geopandas_classification_map(wells_df, ro_df, data_type='ec', classes=None, border=None, 
                                         title=None, unit=None, external_data=None):
    """Create classification map using GeoPandas with user-defined ranges.

    Returns tuple: (image_buffer or None, diagnostic_info dict)

    Args:
        external_data: Optional dict with 'coords' (nx2 array) and 'values' (n array) for direct data input
    """
    all_coords = []
    all_values = []

    diagnostics = {
        'wells_total': 0,
        'wells_valid_coords': 0,
        'wells_valid_values': 0,
        'wells_used': 0,
        'wells_no_coords': [],
        'wells_no_values': [],
        'ro_total': 0,
        'ro_valid_coords': 0,
        'ro_valid_values': 0,
        'ro_used': 0,
        'ro_no_coords': [],
        'ro_no_values': [],
        'failure_reason': None
    }

    if external_data is not None:
        all_coords = external_data['coords'].tolist() if hasattr(external_data['coords'], 'tolist') else list(external_data['coords'])
        all_values = external_data['values'].tolist() if hasattr(external_data['values'], 'tolist') else list(external_data['values'])
        if title is None:
            title = 'Distribution Map'
        if unit is None:
            unit = 'Value'
    else:
        if data_type == 'ec':
            value_col_wells = 'well water salinity'
            value_col_ro = 'ro water salinity'
            if title is None:
                title = 'EC (Salinity) Classification Map'
            if unit is None:
                unit = 'EC'
        elif data_type == 'ph':
            value_col_wells = 'well ph'
            value_col_ro = 'ro ph'
            if title is None:
                title = 'pH Classification Map'
            if unit is None:
                unit = 'pH'
        else:
            value_col_wells = 'well water salinity'
            value_col_ro = 'ro water salinity'
            if title is None:
                title = 'Distribution Map'
            if unit is None:
                unit = 'Value'

        if wells_df is not None and len(wells_df) > 0:
            diagnostics['wells_total'] = len(wells_df)
            for _, row in wells_df.iterrows():
                lat, lon = parse_coordinates(row.get('well google coordinates', ''))
                val = pd.to_numeric(row.get(value_col_wells, np.nan), errors='coerce')

                has_valid_coords = lat is not None and lon is not None
                has_valid_value = not pd.isna(val) and np.isfinite(val)

                if has_valid_coords:
                    diagnostics['wells_valid_coords'] += 1
                else:
                    well_id = row.get('well number', 'Unknown')
                    farm_id = row.get('farm number', 'Unknown')
                    diagnostics['wells_no_coords'].append(f"Well {well_id} (Farm {farm_id})")

                if has_valid_value:
                    diagnostics['wells_valid_values'] += 1
                else:
                    well_id = row.get('well number', 'Unknown')
                    farm_id = row.get('farm number', 'Unknown')
                    if has_valid_coords:
                        diagnostics['wells_no_values'].append(f"Well {well_id} (Farm {farm_id})")

                if has_valid_coords and has_valid_value:
                    all_coords.append([lon, lat])
                    all_values.append(val)
                    diagnostics['wells_used'] += 1

        if ro_df is not None and len(ro_df) > 0:
            diagnostics['ro_total'] = len(ro_df)
            for _, row in ro_df.iterrows():
                lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
                val = pd.to_numeric(row.get(value_col_ro, np.nan), errors='coerce')

                has_valid_coords = lat is not None and lon is not None
                has_valid_value = not pd.isna(val) and np.isfinite(val)

                if has_valid_coords:
                    diagnostics['ro_valid_coords'] += 1
                else:
                    ro_id = row.get('ro number', 'Unknown')
                    farm_id = row.get('farm number', 'Unknown')
                    diagnostics['ro_no_coords'].append(f"RO {ro_id} (Farm {farm_id})")

                if has_valid_value:
                    diagnostics['ro_valid_values'] += 1
                else:
                    ro_id = row.get('ro number', 'Unknown')
                    farm_id = row.get('farm number', 'Unknown')
                    if has_valid_coords:
                        diagnostics['ro_no_values'].append(f"RO {ro_id} (Farm {farm_id})")

                if has_valid_coords and has_valid_value:
                    all_coords.append([lon, lat])
                    all_values.append(val)
                    diagnostics['ro_used'] += 1

    if len(all_coords) < 3:
        diagnostics['failure_reason'] = f'Insufficient data points: {len(all_coords)} (need at least 3)'
        return None, diagnostics

    coords = np.array(all_coords)
    values = np.array(all_values)

    current_border = border if border else get_current_border()
    border_poly = get_shapely_polygon(current_border)

    if border_poly is None or border_poly.is_empty:
        diagnostics['failure_reason'] = 'Border polygon is None or empty'
        return None, diagnostics

    bounds = border_poly.bounds
    lon_min, lat_min, lon_max, lat_max = bounds

    if not all(np.isfinite([lon_min, lat_min, lon_max, lat_max])):
        diagnostics['failure_reason'] = f'Invalid bounds: {bounds}'
        return None, diagnostics

    try:
        lon_pad = (lon_max - lon_min) * 0.05
        lat_pad = (lat_max - lat_min) * 0.05

        if not np.isfinite(lon_pad) or not np.isfinite(lat_pad):
            lon_pad = 0.1
            lat_pad = 0.1

        resolution = 250
        grid_lon = np.linspace(lon_min - lon_pad, lon_max + lon_pad, resolution)
        grid_lat = np.linspace(lat_min - lat_pad, lat_max + lat_pad, resolution)
        grid_x, grid_y = np.meshgrid(grid_lon, grid_lat)

        zi_grid = rbf_interpolation(coords[:, 0], coords[:, 1], values, grid_x, grid_y, smooth=0.05)

        mask = np.zeros_like(zi_grid, dtype=bool)
        for i in range(resolution):
            for j in range(resolution):
                pt = Point(grid_x[i, j], grid_y[i, j])
                mask[i, j] = border_poly.contains(pt)

        zi_masked = np.ma.array(zi_grid, mask=~mask)

        fig, ax = plt.subplots(figsize=(12, 10))

        ax.set_xlim(lon_min - lon_pad, lon_max + lon_pad)
        ax.set_ylim(lat_min - lat_pad, lat_max + lat_pad)
        ax.set_aspect('equal')

        if classes and len(classes) > 0:
            n_classes = len(classes)

            sorted_classes = sorted(classes, key=lambda x: x[0])
            thresholds = [c[0] for c in sorted_classes]
            class_labels = [c[1] for c in sorted_classes]

            levels = [0] + thresholds

            if data_type == 'ph':
                ph_colors = ['#FF4500', '#FF8C00', '#FFA500', '#00AA00', '#9370DB', '#8A2BE2', '#4B0082']
                base_colors = ph_colors
            elif data_type == 'rainfall':
                rainfall_colors = ['#E0F7FA', '#80DEEA', '#26C6DA', '#0097A7', '#00695C']
                base_colors = rainfall_colors
            else:
                base_colors = ['#0000FF', '#00FF00', '#FFFF00', '#FFA500', '#FF0000', '#800080', '#00FFFF', '#FF69B4', '#8B4513', '#2F4F4F']

            colors_to_use = base_colors[:n_classes] if n_classes <= len(base_colors) else (base_colors * ((n_classes // len(base_colors)) + 1))[:n_classes]

            cmap = mcolors.ListedColormap(colors_to_use)
            norm = mcolors.BoundaryNorm(levels, cmap.N)
        else:
            cmap = plt.cm.RdYlBu_r
            norm = None
            levels = 15
            colors_to_use = None
            class_labels = None

        cs = ax.contourf(grid_x, grid_y, zi_masked, levels=levels, 
                         cmap=cmap, norm=norm, extend='neither')

        border_gdf = gpd.GeoDataFrame(geometry=[border_poly], crs="EPSG:4326")
        border_gdf.boundary.plot(ax=ax, color='black', linewidth=2)

        ax.grid(True, linewidth=0.5, color='gray', alpha=0.5)
        ax.set_xlabel('Longitude', fontsize=11)
        ax.set_ylabel('Latitude', fontsize=11)

        cbar = plt.colorbar(cs, ax=ax, orientation='vertical', pad=0.02, shrink=0.8, ticks=[])
        cbar.ax.set_yticklabels([])

        if classes and colors_to_use:
            patches = [plt.Rectangle((0, 0), 1, 1, facecolor=c) for c in colors_to_use]
            ax.legend(patches, class_labels, loc='lower left', fontsize=9, title='Classification')

        ax.set_title(title, fontsize=14, fontweight='bold')

        plt.tight_layout()

        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=150, bbox_inches='tight', facecolor='white')
        buf.seek(0)
        plt.close(fig)

        return buf, diagnostics
    except Exception as e:
        diagnostics['failure_reason'] = f'Map generation error: {str(e)}'
        plt.close('all')
        return None, diagnostics

st.set_page_config(
    page_title="Farm Water Management Dashboard",
    page_icon="",
    layout="wide",
    initial_sidebar_state="expanded"
)

st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1E88E5;
        text-align: center;
        margin-bottom: 1rem;
    }
    .sub-header {
        font-size: 1.2rem;
        color: #666;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        text-align: center;
    }
    .stTabs [data-baseweb="tab-list"] {
        gap: 24px;
    }
    .stTabs [data-baseweb="tab"] {
        padding: 10px 20px;
    }
</style>
""", unsafe_allow_html=True)

def dms_to_decimal(dms_str):
    """Convert DMS (Degrees Minutes Seconds) string to decimal degrees.

    Handles formats like: 25o31'40"N, 2531'40"N, 25d31m40sN, etc.
    """
    if not dms_str:
        return None

    dms_str = str(dms_str).strip().upper()

    direction = None
    if dms_str.endswith('N') or dms_str.endswith('S') or dms_str.endswith('E') or dms_str.endswith('W'):
        direction = dms_str[-1]
        dms_str = dms_str[:-1]

    dms_pattern = r'(\d+)[oOdD]?\s*(\d+)[\'mM]?\s*(\d+(?:\.\d+)?)[\"sS]?'
    match = re.match(dms_pattern, dms_str)

    if match:
        degrees = float(match.group(1))
        minutes = float(match.group(2))
        seconds = float(match.group(3))

        decimal = degrees + (minutes / 60) + (seconds / 3600)

        if direction in ['S', 'W']:
            decimal = -decimal

        return decimal

    return None

def parse_coordinates(coord_str):
    """Parse Google coordinates string to lat, lon.

    Supports multiple formats:
    - Decimal: "25.5277, 51.3588" or "25.5277 51.3588"
    - DMS: "25o31'40\"N 51o21'32\"E" or "2531'40\"N, 5121'32\"E"
    """
    if pd.isna(coord_str) or coord_str == '' or coord_str is None:
        return None, None

    coord_str_check = str(coord_str).strip().lower()
    if coord_str_check in ['nan', 'none', 'null', '']:
        return None, None

    try:
        coord_str = str(coord_str).strip()

        dms_pattern = r'(\d+[oOdD]?\s*\d+[\'mM]?\s*\d+(?:\.\d+)?[\"sS]?\s*[NSEW])'
        dms_matches = re.findall(dms_pattern, coord_str, re.IGNORECASE)

        if len(dms_matches) >= 2:
            lat_str = dms_matches[0]
            lon_str = dms_matches[1]

            lat = dms_to_decimal(lat_str)
            lon = dms_to_decimal(lon_str)

            if lat is not None and lon is not None:
                if 'N' in lat_str.upper() or 'S' in lat_str.upper():
                    pass
                elif 'E' in lat_str.upper() or 'W' in lat_str.upper():
                    lat, lon = lon, lat

                if -90 <= lat <= 90 and -180 <= lon <= 180:
                    return lat, lon

        parts = re.split(r'[,\s]+', coord_str)
        if len(parts) >= 2:
            lat = float(parts[0].strip())
            lon = float(parts[1].strip())
            if -90 <= lat <= 90 and -180 <= lon <= 180:
                return lat, lon
    except (ValueError, IndexError):
        pass
    return None, None

def validate_wells_data(df):
    """Validate wells data columns."""
    required_cols = ['farm number', 'well number', 'well status', 'well google coordinates', 
                     'well water salinity', 'well ph', 'well supplies to']
    df.columns = df.columns.str.lower().str.strip()
    missing = [col for col in required_cols if col not in df.columns]
    return len(missing) == 0, missing, df

def validate_ro_data(df):
    """Validate RO data columns."""
    required_cols = ['farm number', 'ro number', 'ro status', 'ro google coordinates',
                     'ro water salinity', 'ro ph']
    df.columns = df.columns.str.lower().str.strip()
    missing = [col for col in required_cols if col not in df.columns]
    return len(missing) == 0, missing, df

def filter_rows_with_valid_coordinates(df, coord_column):
    """Filter dataframe to retain only rows with valid geographic coordinates.

    Returns tuple: (filtered_df, skipped_rows_info)
    """
    if df is None or len(df) == 0:
        return df, []

    valid_indices = []
    skipped_rows = []

    for idx, row in df.iterrows():
        coord_str = row.get(coord_column, '')
        lat, lon = parse_coordinates(coord_str)
        if lat is not None and lon is not None:
            valid_indices.append(idx)
        else:
            row_id = row.get('well number', row.get('ro number', idx))
            farm = row.get('farm number', 'Unknown')
            skipped_rows.append(f"Farm {farm}, ID {row_id}: '{coord_str}'")

    filtered_df = df.loc[valid_indices].copy()
    return filtered_df, skipped_rows

def create_map(wells_df=None, ro_df=None, show_wells=True, show_ro=True):
    """Create interactive Folium map with wells and RO units."""
    all_coords = []

    if wells_df is not None and show_wells and len(wells_df) > 0:
        for _, row in wells_df.iterrows():
            lat, lon = parse_coordinates(row.get('well google coordinates', ''))
            if lat is not None and lon is not None:
                all_coords.append([lat, lon])

    if ro_df is not None and show_ro and len(ro_df) > 0:
        for _, row in ro_df.iterrows():
            lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
            if lat is not None and lon is not None:
                all_coords.append([lat, lon])

    if all_coords:
        center_lat = sum(c[0] for c in all_coords) / len(all_coords)
        center_lon = sum(c[1] for c in all_coords) / len(all_coords)
        zoom = 10
    else:
        center_lat, center_lon = 25.3, 51.2
        zoom = 8

    m = folium.Map(location=[center_lat, center_lon], zoom_start=zoom, tiles=None)

    folium.TileLayer(
        tiles='https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
        attr='Google',
        name='Google Maps',
        overlay=False,
        control=True,
        show=True
    ).add_to(m)

    folium.TileLayer(
        tiles='https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}',
        attr='Google',
        name='Google Satellite Hybrid',
        overlay=False,
        control=True,
        show=False
    ).add_to(m)

    folium.TileLayer(
        tiles='https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
        attr='Google',
        name='Google Satellite',
        overlay=False,
        control=True,
        show=False
    ).add_to(m)

    folium.TileLayer(
        tiles='OpenStreetMap',
        name='OpenStreetMap',
        overlay=False,
        control=True,
        show=False
    ).add_to(m)

    used_coords = set()

    if wells_df is not None and show_wells:
        for _, row in wells_df.iterrows():
            lat, lon = parse_coordinates(row.get('well google coordinates', ''))
            if lat is not None and lon is not None:
                coord_key = (round(lat, 6), round(lon, 6))
                offset = 0
                while coord_key in used_coords:
                    offset += 0.00001
                    coord_key = (round(lat + offset, 6), round(lon + offset, 6))
                used_coords.add(coord_key)
                display_lat, display_lon = coord_key

                status = str(row.get('well status', '')).lower()
                is_active = status in ['active', 'yes', '1', 'true']
                color = 'green' if is_active else 'red'

                popup_html = f"""
                <div style="width: 200px;">
                    <h4 style="color: #1E88E5; margin-bottom: 10px;">Well Information</h4>
                    <b>Farm #:</b> {row.get('farm number', 'N/A')}<br>
                    <b>Well #:</b> {row.get('well number', 'N/A')}<br>
                    <b>Status:</b> {'Active' if is_active else 'Inactive'}<br>
                    <b>Salinity:</b> {row.get('well water salinity', 'N/A')}<br>
                    <b>pH:</b> {row.get('well ph', 'N/A')}<br>
                    <b>Supplies:</b> {row.get('well supplies to', 'N/A')}
                </div>
                """

                folium.Marker(
                    location=[display_lat, display_lon],
                    popup=folium.Popup(popup_html, max_width=250),
                    icon=folium.Icon(color=color, icon='tint', prefix='fa', icon_color='white'),
                    tooltip=f"Well {row.get('well number', 'N/A')} - Farm {row.get('farm number', 'N/A')}"
                ).add_to(m)

    if ro_df is not None and show_ro:
        for _, row in ro_df.iterrows():
            lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
            if lat is not None and lon is not None:
                coord_key = (round(lat, 6), round(lon, 6))
                offset = 0
                while coord_key in used_coords:
                    offset += 0.00001
                    coord_key = (round(lat + offset, 6), round(lon + offset, 6))
                used_coords.add(coord_key)
                display_lat, display_lon = coord_key

                status = str(row.get('ro status', '')).lower()
                is_active = status in ['active', 'yes', '1', 'true']
                color = 'blue' if is_active else 'orange'

                popup_html = f"""
                <div style="width: 200px;">
                    <h4 style="color: #FF5722; margin-bottom: 10px;">RO Unit Information</h4>
                    <b>Farm #:</b> {row.get('farm number', 'N/A')}<br>
                    <b>RO #:</b> {row.get('ro number', 'N/A')}<br>
                    <b>Status:</b> {'Active' if is_active else 'Inactive'}<br>
                    <b>Salinity:</b> {row.get('ro water salinity', 'N/A')}<br>
                    <b>pH:</b> {row.get('ro ph', 'N/A')}
                </div>
                """

                folium.Marker(
                    location=[display_lat, display_lon],
                    popup=folium.Popup(popup_html, max_width=250),
                    icon=folium.Icon(color=color, icon='filter', prefix='fa', icon_color='white'),
                    tooltip=f"RO {row.get('ro number', 'N/A')} - Farm {row.get('farm number', 'N/A')}"
                ).add_to(m)

    folium.LayerControl().add_to(m)

    legend_html = '''
    <div style="position: fixed; bottom: 50px; left: 50px; z-index: 1000; background-color: white; 
                padding: 12px 15px; border-radius: 8px; border: 2px solid #666; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
        <p style="margin: 0 0 8px 0; font-weight: bold; font-size: 14px; border-bottom: 1px solid #ddd; padding-bottom: 5px;">Legend</p>
        <div style="display: flex; align-items: center; margin: 5px 0;">
            <i class="fa fa-tint" style="color: green; font-size: 16px; width: 20px;"></i>
            <span style="margin-left: 8px; font-size: 12px;">Active Well</span>
        </div>
        <div style="display: flex; align-items: center; margin: 5px 0;">
            <i class="fa fa-tint" style="color: red; font-size: 16px; width: 20px;"></i>
            <span style="margin-left: 8px; font-size: 12px;">Inactive Well</span>
        </div>
        <div style="display: flex; align-items: center; margin: 5px 0;">
            <i class="fa fa-filter" style="color: blue; font-size: 16px; width: 20px;"></i>
            <span style="margin-left: 8px; font-size: 12px;">Active RO Unit</span>
        </div>
        <div style="display: flex; align-items: center; margin: 5px 0;">
            <i class="fa fa-filter" style="color: orange; font-size: 16px; width: 20px;"></i>
            <span style="margin-left: 8px; font-size: 12px;">Inactive RO Unit</span>
        </div>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))

    return m

def create_status_chart(wells_df, ro_df):
    """Create status distribution chart with vibrant colors."""
    data = []

    if wells_df is not None and len(wells_df) > 0:
        status_col = wells_df['well status'].astype(str).str.lower()
        active_wells = status_col.isin(['active', 'yes', '1', 'true']).sum()
        inactive_wells = len(wells_df) - active_wells
        data.append({'Type': 'Wells', 'Status': 'Active', 'Count': active_wells})
        data.append({'Type': 'Wells', 'Status': 'Inactive', 'Count': inactive_wells})

    if ro_df is not None and len(ro_df) > 0:
        status_col = ro_df['ro status'].astype(str).str.lower()
        active_ro = status_col.isin(['active', 'yes', '1', 'true']).sum()
        inactive_ro = len(ro_df) - active_ro
        data.append({'Type': 'RO Units', 'Status': 'Active', 'Count': active_ro})
        data.append({'Type': 'RO Units', 'Status': 'Inactive', 'Count': inactive_ro})

    if data:
        df = pd.DataFrame(data)
        fig = px.bar(df, x='Type', y='Count', color='Status', barmode='group',
                     color_discrete_map={'Active': '#00E676', 'Inactive': '#FF1744'},
                     title='Count Active Vs Inactive Wells/RO Units')
        fig.update_layout(
            height=400,
            plot_bgcolor='rgba(0,0,0,0)',
            paper_bgcolor='rgba(0,0,0,0)',
            font=dict(size=12),
            title_font=dict(size=16, color='#1a1a2e'),
            legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1)
        )
        fig.update_traces(marker_line_width=0)
        return fig
    return None

def create_supply_chart(wells_df):
    """Create well supply type distribution chart with vibrant colors."""
    if wells_df is None or len(wells_df) == 0:
        return None

    supply_counts = {}
    for val in wells_df['well supplies to'].dropna():
        val_str = str(val).strip()
        parts = val_str.split(',')
        for part in parts:
            cleaned = part.strip()
            if cleaned:
                supply_counts[cleaned] = supply_counts.get(cleaned, 0) + 1

    if not supply_counts:
        return None

    vibrant_colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F']
    fig = px.pie(values=list(supply_counts.values()), names=list(supply_counts.keys()),
                 title='Water Distribution (Count)',
                 color_discrete_sequence=vibrant_colors)
    fig.update_layout(
        height=400,
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(size=12),
        title_font=dict(size=16, color='#1a1a2e')
    )
    fig.update_traces(textposition='inside', textinfo='percent+label', hole=0.3,
                      marker=dict(line=dict(color='white', width=2)))
    return fig

def create_salinity_chart(wells_df, ro_df, ec_classes=None):
    """Create salinity distribution chart based on EC classes with vibrant colors."""
    if ec_classes is None:
        ec_classes = [
            (500.0, "Low (< 500)"),
            (1000.0, "Medium (500-1000)"),
            (2000.0, "High (1000-2000)"),
            (3000.0, "Very High (2000-3000)"),
            (6000.0, "Extreme (> 3000)")
        ]

    vibrant_colors = ['#00E5FF', '#00E676', '#FFEA00', '#FF9100', '#FF1744']

    all_salinity = []
    if wells_df is not None and len(wells_df) > 0:
        salinity = pd.to_numeric(wells_df['well water salinity'], errors='coerce').dropna()
        all_salinity.extend(salinity.tolist())
    if ro_df is not None and len(ro_df) > 0:
        salinity = pd.to_numeric(ro_df['ro water salinity'], errors='coerce').dropna()
        all_salinity.extend(salinity.tolist())

    if not all_salinity:
        return None

    class_counts = {}
    for val in all_salinity:
        for i, (threshold, label) in enumerate(ec_classes):
            if val <= threshold:
                class_counts[label] = class_counts.get(label, 0) + 1
                break

    if not class_counts:
        return None

    labels = [c[1] for c in ec_classes if c[1] in class_counts]
    values = [class_counts.get(c[1], 0) for c in ec_classes if c[1] in class_counts]
    colors = [vibrant_colors[i] for i, c in enumerate(ec_classes) if c[1] in class_counts]

    fig = go.Figure(data=[go.Bar(x=labels, y=values, marker_color=colors, 
                                  marker_line_width=0, text=values, textposition='outside')])
    fig.update_layout(
        title='Well EC Class Distribution',
        xaxis_title='EC Class',
        yaxis_title='Count',
        height=400,
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(size=12),
        title_font=dict(size=16, color='#1a1a2e'),
        showlegend=False
    )
    return fig

def create_ph_chart(wells_df, ro_df, ph_classes=None):
    """Create pH distribution chart based on pH classes with vibrant colors."""
    if ph_classes is None:
        ph_classes = [
            (6.5, "Acidic (< 6.5)"),
            (7.5, "Neutral (6.5-7.5)"),
            (8.0, "Slightly Alkaline (7.5-8.0)"),
            (8.5, "Alkaline (8.0-8.5)"),
            (14.0, "Highly Alkaline (> 8.5)")
        ]

    vibrant_colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#9B59B6', '#E74C3C']

    all_ph = []
    if wells_df is not None and len(wells_df) > 0:
        ph = pd.to_numeric(wells_df['well ph'], errors='coerce').dropna()
        all_ph.extend(ph.tolist())
    if ro_df is not None and len(ro_df) > 0:
        ph = pd.to_numeric(ro_df['ro ph'], errors='coerce').dropna()
        all_ph.extend(ph.tolist())

    if not all_ph:
        return None

    class_counts = {}
    for val in all_ph:
        for i, (threshold, label) in enumerate(ph_classes):
            if val <= threshold:
                class_counts[label] = class_counts.get(label, 0) + 1
                break

    if not class_counts:
        return None

    labels = [c[1] for c in ph_classes if c[1] in class_counts]
    values = [class_counts.get(c[1], 0) for c in ph_classes if c[1] in class_counts]
    colors = [vibrant_colors[i] for i, c in enumerate(ph_classes) if c[1] in class_counts]

    fig = go.Figure(data=[go.Bar(x=labels, y=values, marker_color=colors,
                                  marker_line_width=0, text=values, textposition='outside')])
    fig.update_layout(
        title='Well pH Class Distribution',
        xaxis_title='pH Class',
        yaxis_title='Count',
        height=400,
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(size=12),
        title_font=dict(size=16, color='#1a1a2e'),
        showlegend=False
    )
    return fig

def calculate_avg_active_per_farm(wells_df, ro_df):
    """Calculate average active wells and RO units per farm as numeric values."""
    avg_active_wells = 0.0
    avg_active_ro = 0.0

    if wells_df is not None and len(wells_df) > 0:
        wells_df_copy = wells_df.copy()
        wells_df_copy['is_active'] = wells_df_copy['well status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true']).astype(int)
        active_per_farm = wells_df_copy.groupby('farm number')['is_active'].sum()
        num_farms = len(active_per_farm)
        if num_farms > 0:
            avg_active_wells = active_per_farm.sum() / num_farms

    if ro_df is not None and len(ro_df) > 0:
        ro_df_copy = ro_df.copy()
        ro_df_copy['is_active'] = ro_df_copy['ro status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true']).astype(int)
        active_per_farm = ro_df_copy.groupby('farm number')['is_active'].sum()
        num_farms = len(active_per_farm)
        if num_farms > 0:
            avg_active_ro = active_per_farm.sum() / num_farms

    return avg_active_wells, avg_active_ro

def expand_supply_types(wells_df):
    """Expand supply types column to handle multiple values separated by commas."""
    if wells_df is None or len(wells_df) == 0:
        return wells_df

    all_supplies = []
    for val in wells_df['well supplies to'].dropna():
        val_str = str(val).strip()
        parts = val_str.split(',')
        for part in parts:
            cleaned = part.strip()
            if cleaned:
                all_supplies.append(cleaned.lower())
    return all_supplies

def get_unique_supply_types(wells_df):
    """Get unique supply types from wells data, handling comma-separated values per cell."""
    if wells_df is None or len(wells_df) == 0:
        return []

    unique_supplies = set()
    for val in wells_df['well supplies to'].dropna():
        val_str = str(val).strip()
        parts = val_str.split(',')
        for part in parts:
            cleaned = part.strip()
            if cleaned:
                unique_supplies.add(cleaned)
    return sorted(list(unique_supplies))

def filter_wells_by_supply(wells_df, selected_supplies):
    """Filter wells by selected supply types, handling comma-separated values per cell.

    Rows with empty/null supply values are always included to avoid dropping inactive wells.
    """
    if wells_df is None or len(wells_df) == 0 or not selected_supplies:
        return wells_df

    mask = wells_df['well supplies to'].apply(
        lambda x: True if pd.isna(x) or str(x).strip() == '' else any(
            supply.strip().lower() in [s.lower() for s in selected_supplies]
            for supply in str(x).strip().split(',') if supply.strip()
        )
    )
    return wells_df[mask]

def sanitize_text_for_pdf(text):
    """Sanitize text for PDF to handle special characters."""
    if text is None:
        return ''
    text = str(text)
    text = text.encode('utf-8', errors='replace').decode('utf-8', errors='replace')
    return text

def create_matplotlib_status_chart(wells_df, ro_df):
    """Create status distribution chart using matplotlib."""
    data = {'Type': [], 'Active': [], 'Inactive': []}

    if wells_df is not None and len(wells_df) > 0:
        status_col = wells_df['well status'].astype(str).str.lower()
        active = status_col.isin(['active', 'yes', '1', 'true']).sum()
        inactive = len(wells_df) - active
        data['Type'].append('Wells')
        data['Active'].append(active)
        data['Inactive'].append(inactive)

    if ro_df is not None and len(ro_df) > 0:
        status_col = ro_df['ro status'].astype(str).str.lower()
        active = status_col.isin(['active', 'yes', '1', 'true']).sum()
        inactive = len(ro_df) - active
        data['Type'].append('RO Units')
        data['Active'].append(active)
        data['Inactive'].append(inactive)

    if not data['Type']:
        return None

    fig, ax = plt.subplots(figsize=(8, 5))
    x = np.arange(len(data['Type']))
    width = 0.35

    bars1 = ax.bar(x - width/2, data['Active'], width, label='Active', color='#00E676')
    bars2 = ax.bar(x + width/2, data['Inactive'], width, label='Inactive', color='#FF1744')

    ax.set_xlabel('Type')
    ax.set_ylabel('Count')
    ax.set_title('Count Active Vs Inactive Wells/RO Units')
    ax.set_xticks(x)
    ax.set_xticklabels(data['Type'])
    ax.legend()

    for bar in bars1:
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{int(bar.get_height())}', ha='center', va='bottom')
    for bar in bars2:
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{int(bar.get_height())}', ha='center', va='bottom')

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight', facecolor='white')
    buf.seek(0)
    plt.close(fig)
    return buf

def create_matplotlib_supply_chart(wells_df):
    """Create supply distribution pie chart using matplotlib."""
    if wells_df is None or len(wells_df) == 0:
        return None

    supply_counts = {}
    for val in wells_df['well supplies to'].dropna():
        val_str = str(val).strip()
        parts = val_str.split(',')
        for part in parts:
            cleaned = part.strip()
            if cleaned:
                supply_counts[cleaned] = supply_counts.get(cleaned, 0) + 1

    if not supply_counts:
        return None

    colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F']

    fig, ax = plt.subplots(figsize=(8, 5))
    wedges, texts, autotexts = ax.pie(
        list(supply_counts.values()), 
        labels=list(supply_counts.keys()),
        autopct='%1.1f%%',
        colors=colors[:len(supply_counts)],
        wedgeprops=dict(width=0.7, edgecolor='white')
    )
    ax.set_title('Water Distribution (Count)')

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight', facecolor='white')
    buf.seek(0)
    plt.close(fig)
    return buf

def create_matplotlib_ec_chart(wells_df, ro_df, ec_classes=None):
    """Create EC distribution chart using matplotlib."""
    if ec_classes is None:
        ec_classes = [
            (500.0, "Low (< 500)"),
            (1000.0, "Medium (500-1000)"),
            (2000.0, "High (1000-2000)"),
            (3000.0, "Very High (2000-3000)"),
            (6000.0, "Extreme (> 3000)")
        ]

    all_salinity = []
    if wells_df is not None and len(wells_df) > 0:
        salinity = pd.to_numeric(wells_df['well water salinity'], errors='coerce').dropna()
        all_salinity.extend(salinity.tolist())
    if ro_df is not None and len(ro_df) > 0:
        salinity = pd.to_numeric(ro_df['ro water salinity'], errors='coerce').dropna()
        all_salinity.extend(salinity.tolist())

    if not all_salinity:
        return None

    class_counts = {}
    for val in all_salinity:
        for i, (threshold, label) in enumerate(ec_classes):
            if val <= threshold:
                class_counts[label] = class_counts.get(label, 0) + 1
                break

    if not class_counts:
        return None

    colors = ['#00E5FF', '#00E676', '#FFEA00', '#FF9100', '#FF1744']
    labels = [c[1] for c in ec_classes if c[1] in class_counts]
    values = [class_counts.get(c[1], 0) for c in ec_classes if c[1] in class_counts]
    bar_colors = [colors[i] for i, c in enumerate(ec_classes) if c[1] in class_counts]

    fig, ax = plt.subplots(figsize=(8, 5))
    bars = ax.bar(labels, values, color=bar_colors)
    ax.set_xlabel('EC Class')
    ax.set_ylabel('Count')
    ax.set_title('Well EC Class Distribution')
    plt.xticks(rotation=45, ha='right')

    for bar in bars:
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{int(bar.get_height())}', ha='center', va='bottom')

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight', facecolor='white')
    buf.seek(0)
    plt.close(fig)
    return buf

def create_matplotlib_ph_chart(wells_df, ro_df, ph_classes=None):
    """Create pH distribution chart using matplotlib."""
    if ph_classes is None:
        ph_classes = [
            (6.5, "Acidic (< 6.5)"),
            (7.5, "Neutral (6.5-7.5)"),
            (8.0, "Slightly Alkaline (7.5-8.0)"),
            (8.5, "Alkaline (8.0-8.5)"),
            (14.0, "Highly Alkaline (> 8.5)")
        ]

    all_ph = []
    if wells_df is not None and len(wells_df) > 0:
        ph = pd.to_numeric(wells_df['well ph'], errors='coerce').dropna()
        all_ph.extend(ph.tolist())
    if ro_df is not None and len(ro_df) > 0:
        ph = pd.to_numeric(ro_df['ro ph'], errors='coerce').dropna()
        all_ph.extend(ph.tolist())

    if not all_ph:
        return None

    class_counts = {}
    for val in all_ph:
        for i, (threshold, label) in enumerate(ph_classes):
            if val <= threshold:
                class_counts[label] = class_counts.get(label, 0) + 1
                break

    if not class_counts:
        return None

    colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#9B59B6', '#E74C3C']
    labels = [c[1] for c in ph_classes if c[1] in class_counts]
    values = [class_counts.get(c[1], 0) for c in ph_classes if c[1] in class_counts]
    bar_colors = [colors[i] for i, c in enumerate(ph_classes) if c[1] in class_counts]

    fig, ax = plt.subplots(figsize=(8, 5))
    bars = ax.bar(labels, values, color=bar_colors)
    ax.set_xlabel('pH Class')
    ax.set_ylabel('Count')
    ax.set_title('Well pH Class Distribution')
    plt.xticks(rotation=45, ha='right')

    for bar in bars:
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{int(bar.get_height())}', ha='center', va='bottom')

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=150, bbox_inches='tight', facecolor='white')
    buf.seek(0)
    plt.close(fig)
    return buf

def generate_pdf_report(wells_df, ro_df, options=None, ec_classes=None, ph_classes=None):
    """Generate PDF report with summary and charts using WeasyPrint and matplotlib."""
    if options is None:
        options = {
            'summary': True,
            'status_chart': True,
            'supply_chart': True,
            'salinity_chart': True,
            'ph_chart': True,
            'avg_per_farm': True,
            'ec_map': False,
            'ph_map': False
        }

    total_farms = set()
    total_wells = 0
    active_wells = 0
    inactive_wells = 0
    total_ro = 0
    active_ro = 0
    inactive_ro = 0
    wells_salinity_avg = wells_ph_avg = ro_salinity_avg = ro_ph_avg = None

    if wells_df is not None and len(wells_df) > 0:
        total_wells = len(wells_df)
        if 'farm number' in wells_df.columns:
            total_farms.update(wells_df['farm number'].dropna().unique())
        status_col = wells_df['well status'].astype(str).str.lower()
        active_wells = int(status_col.isin(['active', 'yes', '1', 'true']).sum())
        inactive_wells = total_wells - active_wells
        salinity = pd.to_numeric(wells_df['well water salinity'], errors='coerce').dropna()
        if len(salinity) > 0:
            wells_salinity_avg = salinity.mean()
        ph = pd.to_numeric(wells_df['well ph'], errors='coerce').dropna()
        if len(ph) > 0:
            wells_ph_avg = ph.mean()

    if ro_df is not None and len(ro_df) > 0:
        total_ro = len(ro_df)
        if 'farm number' in ro_df.columns:
            total_farms.update(ro_df['farm number'].dropna().unique())
        status_col = ro_df['ro status'].astype(str).str.lower()
        active_ro = int(status_col.isin(['active', 'yes', '1', 'true']).sum())
        inactive_ro = total_ro - active_ro
        salinity = pd.to_numeric(ro_df['ro water salinity'], errors='coerce').dropna()
        if len(salinity) > 0:
            ro_salinity_avg = salinity.mean()
        ph = pd.to_numeric(ro_df['ro ph'], errors='coerce').dropna()
        if len(ph) > 0:
            ro_ph_avg = ph.mean()

    avg_wells, avg_ro = calculate_avg_active_per_farm(wells_df, ro_df)

    html_content = f'''
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            @page {{
                size: A4;
                margin: 2cm;
            }}
            body {{
                font-family: Arial, sans-serif;
                font-size: 11pt;
                color: #333;
                line-height: 1.4;
            }}
            h1 {{
                color: #1a1a2e;
                text-align: center;
                font-size: 24pt;
                margin-bottom: 5px;
            }}
            .subtitle {{
                text-align: center;
                color: #666;
                font-size: 12pt;
                margin-bottom: 30px;
            }}
            h2 {{
                color: #2c3e50;
                font-size: 16pt;
                border-bottom: 2px solid #3498db;
                padding-bottom: 5px;
                margin-top: 25px;
            }}
            .summary-grid {{
                display: flex;
                justify-content: space-between;
                gap: 15px;
                margin: 20px 0;
            }}
            .summary-card {{
                background: #f8f9fa;
                border-radius: 8px;
                padding: 15px;
                text-align: center;
                border: 1px solid #e0e0e0;
                flex: 1;
            }}
            .summary-card .value {{
                font-size: 24pt;
                font-weight: bold;
                color: #1a1a2e;
            }}
            .summary-card .label {{
                font-size: 10pt;
                color: #666;
            }}
            .summary-card .detail {{
                font-size: 9pt;
                color: #888;
            }}
            table {{
                width: 100%;
                border-collapse: collapse;
                margin: 15px 0;
            }}
            th {{
                background: #3498db;
                color: white;
                padding: 10px;
                text-align: left;
            }}
            td {{
                padding: 8px 10px;
                border-bottom: 1px solid #eee;
            }}
            tr:nth-child(even) {{
                background: #f8f9fa;
            }}
            .chart-container {{
                text-align: center;
                margin: 20px 0;
                page-break-inside: avoid;
            }}
            .chart-container img {{
                max-width: 100%;
                height: auto;
            }}
            .page-break {{
                page-break-before: always;
            }}
        </style>
    </head>
    <body>
        <h1>Farm Water Management Report</h1>
        <p class="subtitle">Generated Report with Statistical Analysis</p>

        <h2>Summary Statistics</h2>
        <div class="summary-grid">
            <div class="summary-card">
                <div class="value">{len(total_farms)}</div>
                <div class="label">Total Farms</div>
            </div>
            <div class="summary-card">
                <div class="value">{total_wells}</div>
                <div class="label">Total Wells</div>
                <div class="detail">{active_wells} Active / {inactive_wells} Inactive</div>
            </div>
            <div class="summary-card">
                <div class="value">{total_ro}</div>
                <div class="label">Total RO Units</div>
                <div class="detail">{active_ro} Active / {inactive_ro} Inactive</div>
            </div>
        </div>

        <table>
            <tr><th>Metric</th><th>Wells</th><th>RO Units</th></tr>
            <tr><td>Average EC (Salinity)</td><td>{f"{wells_salinity_avg:.2f}" if wells_salinity_avg else "N/A"}</td><td>{f"{ro_salinity_avg:.2f}" if ro_salinity_avg else "N/A"}</td></tr>
            <tr><td>Average pH</td><td>{f"{wells_ph_avg:.2f}" if wells_ph_avg else "N/A"}</td><td>{f"{ro_ph_avg:.2f}" if ro_ph_avg else "N/A"}</td></tr>
            <tr><td>Avg Active per Farm</td><td>{int(round(avg_wells))}</td><td>{int(round(avg_ro))}</td></tr>
        </table>
    '''

    if options.get('status_chart', True):
        status_buf = create_matplotlib_status_chart(wells_df, ro_df)
        if status_buf:
            img_b64 = base64.b64encode(status_buf.getvalue()).decode()
            html_content += f'''
            <div class="page-break"></div>
            <h2>Statistical Charts</h2>
            <div class="chart-container">
                <img src="data:image/png;base64,{img_b64}" alt="Status Distribution">
            </div>
            '''

    if options.get('supply_chart', True) and wells_df is not None and len(wells_df) > 0:
        supply_buf = create_matplotlib_supply_chart(wells_df)
        if supply_buf:
            img_b64 = base64.b64encode(supply_buf.getvalue()).decode()
            html_content += f'''
            <div class="chart-container">
                <img src="data:image/png;base64,{img_b64}" alt="Supply Distribution">
            </div>
            '''

    if options.get('salinity_chart', True):
        ec_buf = create_matplotlib_ec_chart(wells_df, ro_df, ec_classes)
        if ec_buf:
            img_b64 = base64.b64encode(ec_buf.getvalue()).decode()
            html_content += f'''
            <div class="page-break"></div>
            <div class="chart-container">
                <img src="data:image/png;base64,{img_b64}" alt="EC Distribution">
            </div>
            '''

    if options.get('ph_chart', True):
        ph_buf = create_matplotlib_ph_chart(wells_df, ro_df, ph_classes)
        if ph_buf:
            img_b64 = base64.b64encode(ph_buf.getvalue()).decode()
            html_content += f'''
            <div class="chart-container">
                <img src="data:image/png;base64,{img_b64}" alt="pH Distribution">
            </div>
            '''

    ec_map_buffer = options.get('ec_map_buffer')
    if options.get('ec_map', False) and ec_map_buffer:
        ec_map_buffer.seek(0)
        img_b64 = base64.b64encode(ec_map_buffer.getvalue()).decode()
        html_content += f'''
        <div class="page-break"></div>
        <h2>EC (Salinity) Spatial Distribution Map</h2>
        <div class="chart-container">
            <img src="data:image/png;base64,{img_b64}" alt="EC Map">
        </div>
        '''

    ph_map_buffer = options.get('ph_map_buffer')
    if options.get('ph_map', False) and ph_map_buffer:
        ph_map_buffer.seek(0)
        img_b64 = base64.b64encode(ph_map_buffer.getvalue()).decode()
        html_content += f'''
        <div class="page-break"></div>
        <h2>pH Spatial Distribution Map</h2>
        <div class="chart-container">
            <img src="data:image/png;base64,{img_b64}" alt="pH Map">
        </div>
        '''

    html_content += '''
    </body>
    </html>
    '''

    pdf_bytes = HTML(string=html_content).write_pdf()
    return pdf_bytes

def main():
    st.markdown('<h1 class="main-header">Farm Water Management Dashboard</h1>', unsafe_allow_html=True)
    st.markdown('<p class="sub-header">Upload your Excel file to visualize wells and RO units data</p>', unsafe_allow_html=True)

    if 'wells_df' not in st.session_state:
        st.session_state.wells_df = None
    if 'ro_df' not in st.session_state:
        st.session_state.ro_df = None
    if 'wells_df_raw' not in st.session_state:
        st.session_state.wells_df_raw = None
    if 'ro_df_raw' not in st.session_state:
        st.session_state.ro_df_raw = None

    with st.sidebar:
        st.header("Data Upload")

        st.caption("Upload an Excel file with two sheets:")
        st.caption("**Sheet 1 (Wells):** Farm Number, Well Number, Well Status, Well Google Coordinates, Well Water Salinity, Well pH, Well Supplies To")
        st.caption("**Sheet 2 (RO):** Farm Number, RO Number, RO Status, RO Google Coordinates, RO Water Salinity, RO pH")

        uploaded_file = st.file_uploader("Upload Excel File", type=['xlsx', 'xls'], key='data_upload')

        st.divider()

        if uploaded_file:
            try:
                excel_file = pd.ExcelFile(uploaded_file)
                sheet_names = excel_file.sheet_names

                if len(sheet_names) >= 2:
                    wells_df_raw = pd.read_excel(excel_file, sheet_name=0)
                    valid_wells, missing_wells, wells_df_raw = validate_wells_data(wells_df_raw)

                    ro_df_raw = pd.read_excel(excel_file, sheet_name=1)
                    valid_ro, missing_ro, ro_df_raw = validate_ro_data(ro_df_raw)

                    if valid_wells:
                        st.session_state.wells_df_raw = wells_df_raw.copy()
                        wells_df_filtered, skipped_wells = filter_rows_with_valid_coordinates(wells_df_raw, 'well google coordinates')
                        st.session_state.wells_df = wells_df_filtered
                        st.success(f"Wells data loaded from '{sheet_names[0]}' ({len(wells_df_filtered)} of {len(wells_df_raw)} rows)")
                        if skipped_wells:
                            with st.expander(f" {len(skipped_wells)} wells skipped (invalid coordinates)"):
                                for info in skipped_wells:
                                    st.text(info)
                    else:
                        st.error(f"Sheet 1 missing columns: {', '.join(missing_wells)}")

                    if valid_ro:
                        st.session_state.ro_df_raw = ro_df_raw.copy()
                        ro_df_filtered, skipped_ro = filter_rows_with_valid_coordinates(ro_df_raw, 'ro google coordinates')
                        st.session_state.ro_df = ro_df_filtered
                        st.success(f"RO data loaded from '{sheet_names[1]}' ({len(ro_df_filtered)} of {len(ro_df_raw)} rows)")
                        if skipped_ro:
                            with st.expander(f" {len(skipped_ro)} RO units skipped (invalid coordinates)"):
                                for info in skipped_ro:
                                    st.text(info)
                    else:
                        st.error(f"Sheet 2 missing columns: {', '.join(missing_ro)}")
                elif len(sheet_names) == 1:
                    wells_df_raw = pd.read_excel(excel_file, sheet_name=0)
                    valid_wells, missing_wells, wells_df_raw = validate_wells_data(wells_df_raw)
                    if valid_wells:
                        st.session_state.wells_df_raw = wells_df_raw.copy()
                        wells_df_filtered, skipped_wells = filter_rows_with_valid_coordinates(wells_df_raw, 'well google coordinates')
                        st.session_state.wells_df = wells_df_filtered
                        st.success(f"Wells data loaded ({len(wells_df_filtered)} of {len(wells_df_raw)} rows)!")
                        if skipped_wells:
                            with st.expander(f" {len(skipped_wells)} wells skipped (invalid coordinates)"):
                                for info in skipped_wells:
                                    st.text(info)
                    else:
                        valid_ro, missing_ro, ro_df_raw = validate_ro_data(wells_df_raw)
                        if valid_ro:
                            st.session_state.ro_df_raw = ro_df_raw.copy()
                            ro_df_filtered, skipped_ro = filter_rows_with_valid_coordinates(ro_df_raw, 'ro google coordinates')
                            st.session_state.ro_df = ro_df_filtered
                            st.success(f"RO data loaded ({len(ro_df_filtered)} of {len(ro_df_raw)} rows)!")
                            if skipped_ro:
                                with st.expander(f" {len(skipped_ro)} RO units skipped (invalid coordinates)"):
                                    for info in skipped_ro:
                                        st.text(info)
                        else:
                            st.error("Could not identify data format in the sheet.")
                    st.warning("Only one sheet found. Please upload a file with two sheets (Wells and RO).")
                else:
                    st.error("No sheets found in the uploaded file.")
            except Exception as e:
                st.error(f"Error reading file: {str(e)}")
        else:
            st.session_state.wells_df = None
            st.session_state.ro_df = None
            st.session_state.wells_df_raw = None
            st.session_state.ro_df_raw = None
            st.session_state.ec_classes_saved = None
            st.session_state.ph_classes_saved = None

        st.divider()
        st.header("Filters")

        show_wells = st.checkbox("Show Wells", value=True)
        show_ro = st.checkbox("Show RO Units", value=True)

        all_farms = set()
        if st.session_state.wells_df is not None:
            all_farms.update(str(f) for f in st.session_state.wells_df['farm number'].unique())
        if st.session_state.ro_df is not None:
            all_farms.update(str(f) for f in st.session_state.ro_df['farm number'].unique())

        if all_farms:
            sorted_farms = sorted(all_farms, key=lambda x: (x.isdigit(), int(x) if x.isdigit() else x))
            selected_farms = st.multiselect("Filter by Farm", sorted_farms, default=sorted_farms)
        else:
            selected_farms = []

        status_filter = st.selectbox("Status Filter", ["All", "Active Only", "Inactive Only"])

        if st.session_state.wells_df is not None:
            supply_types = get_unique_supply_types(st.session_state.wells_df)
            selected_supplies = st.multiselect("Filter by Supply Type", supply_types, default=supply_types)
        else:
            selected_supplies = []

    wells_df = st.session_state.wells_df
    ro_df = st.session_state.ro_df

    if wells_df is not None and selected_farms:
        wells_df = wells_df[wells_df['farm number'].astype(str).isin(selected_farms)]
        if selected_supplies:
            wells_df = filter_wells_by_supply(wells_df, selected_supplies)
        if status_filter == "Active Only":
            wells_df = wells_df[wells_df['well status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true'])]
        elif status_filter == "Inactive Only":
            wells_df = wells_df[~wells_df['well status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true'])]

    if ro_df is not None and selected_farms:
        ro_df = ro_df[ro_df['farm number'].astype(str).isin(selected_farms)]
        if status_filter == "Active Only":
            ro_df = ro_df[ro_df['ro status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true'])]
        elif status_filter == "Inactive Only":
            ro_df = ro_df[~ro_df['ro status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true'])]

    if wells_df is None and ro_df is None:
        st.info("Please upload your Excel file using the sidebar to get started.")

        with st.expander("Expected Data Format"):
            st.markdown("""
            Upload a single Excel file with **two sheets**:

            ### Sheet 1 - Wells Data
            | Column | Description |
            |--------|-------------|
            | Farm Number | Unique farm identifier |
            | Well Number | Unique well identifier |
            | Well Status | Active or Not Active |
            | Well Google Coordinates | Lat, Lng format |
            | Well Water Salinity | Numeric value |
            | Well pH | Numeric value |
            | Well Supplies To | vegetables, fodder crops, palm trees, fruit trees, mix |

            ### Sheet 2 - RO Data
            | Column | Description |
            |--------|-------------|
            | Farm Number | Unique farm identifier |
            | RO Number | Unique RO unit identifier |
            | RO Status | Active or Not Active |
            | RO Google Coordinates | Lat, Lng format |
            | RO Water Salinity | Numeric value |
            | RO pH | Numeric value |
            """)
        return

    col1, col2, col3, col4, col5 = st.columns(5)

    with col1:
        all_farms_count = set()
        if st.session_state.wells_df_raw is not None:
            farms = st.session_state.wells_df_raw['farm number'].dropna().unique()
            all_farms_count.update(str(f) for f in farms if pd.notna(f))
        if st.session_state.ro_df_raw is not None:
            farms = st.session_state.ro_df_raw['farm number'].dropna().unique()
            all_farms_count.update(str(f) for f in farms if pd.notna(f))
        st.metric("Total Farms", len(all_farms_count))

    with col2:
        total_wells = len(wells_df) if wells_df is not None else 0
        st.metric("Total Wells", total_wells)

    with col3:
        active_wells = 0
        if wells_df is not None and len(wells_df) > 0:
            active_wells = wells_df['well status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true']).sum()
        st.metric("Active Wells", active_wells)

    with col4:
        total_ro = len(ro_df) if ro_df is not None else 0
        st.metric("Total RO Units", total_ro)

    with col5:
        active_ro = 0
        if ro_df is not None and len(ro_df) > 0:
            active_ro = ro_df['ro status'].astype(str).str.lower().isin(['active', 'yes', '1', 'true']).sum()
        st.metric("Active RO Units", active_ro)

    st.divider()

    tabs = st.tabs(["View Locations", "EC/pH (Wells)", "Statistics", "Rainfall Events", "Data Preview"])

    with tabs[0]:
        st.subheader("Interactive Map")
        if (wells_df is not None and show_wells) or (ro_df is not None and show_ro):
            m = create_map(wells_df if show_wells else None, ro_df if show_ro else None, show_wells, show_ro)
            st_folium(m, width=None, height=600, use_container_width=True)
        else:
            st.warning("No data to display on map. Please upload files and enable display options.")

    with tabs[1]:
        st.subheader("Spatial Distribution Maps")

        if status_filter == "Inactive Only":
            st.info("EC/pH spatial distribution is not available for inactive units. Please select 'All' or 'Active Only' to view distribution maps.")
        else:
            st.caption("Define custom classes for EC (Salinity) and pH to visualize spatial distribution within a custom border.")

            if 'custom_border' not in st.session_state:
                saved_border = load_border_from_file()
                st.session_state.custom_border = saved_border
            if 'crop_class_values' not in st.session_state:
                st.session_state.crop_class_values = {crop: {**CROP_DEFAULTS[crop]} for crop in CROP_DEFAULTS}
            if 'selected_crop' not in st.session_state:
                st.session_state.selected_crop = "Tomatoes"
            if 'ec_classes_saved' not in st.session_state:
                st.session_state.ec_classes_saved = None
            if 'ph_classes_saved' not in st.session_state:
                st.session_state.ph_classes_saved = None

            with st.expander("Border Configuration", expanded=False):
                st.markdown("**Upload GeoJSON Border File**")
                st.caption("Upload a GeoJSON file with border coordinates (FeatureCollection, Feature, Polygon, or MultiPolygon)")

                border_file = st.file_uploader("Upload GeoJSON border file", type=['json', 'geojson'], key="border_file")

                if border_file:
                    try:
                        content = border_file.read().decode('utf-8')
                        parsed_border = parse_border_file(content)
                        if parsed_border:
                            st.session_state.custom_border = parsed_border
                            save_border_to_file(parsed_border)
                            border_type = parsed_border.get('type', 'Unknown')
                            if border_type == 'Polygon':
                                num_points = len(parsed_border["coordinates"][0])
                            elif border_type == 'MultiPolygon':
                                num_points = sum(len(ring[0]) for ring in parsed_border["coordinates"])
                            else:
                                num_points = 0
                            st.success(f"Border loaded and saved! Type: {border_type}, Points: {num_points}")
                        else:
                            st.error("Could not parse border file. Please check the format.")
                    except Exception as e:
                        st.error(f"Error reading file: {str(e)}")

                if st.session_state.custom_border:
                    current = st.session_state.custom_border
                    border_type = current.get('type', 'Unknown')
                    st.info(f"Using custom border ({border_type}) - saved for future sessions")
                    if st.button("Clear Custom Border", key="clear_border"):
                        st.session_state.custom_border = None
                        st.session_state.ec_classes_saved = None
                        st.session_state.ph_classes_saved = None
                        delete_saved_border()
                        st.rerun()
                else:
                    st.info("Using default border (Qatar). Upload a GeoJSON file to use a custom border.")

            crop_list = list(CROP_DEFAULTS.keys())
            selected_crop = st.selectbox(
                "Select Crop",
                crop_list,
                index=crop_list.index(st.session_state.selected_crop),
                key="crop_selector"
            )
            st.session_state.selected_crop = selected_crop

            crop_values = st.session_state.crop_class_values[selected_crop]

            class_col1, class_col2 = st.columns(2)

            with class_col1:
                st.markdown(f"**EC (Salinity) Classification for {selected_crop}**")
                ec_class1 = st.number_input("Class 1 - Low (max value)", value=float(crop_values["ec"][0]), key=f"ec1_{selected_crop}")
                ec_class2 = st.number_input("Class 2 - Medium (max value)", value=float(crop_values["ec"][1]), key=f"ec2_{selected_crop}")
                ec_class3 = st.number_input("Class 3 - High (max value)", value=float(crop_values["ec"][2]), key=f"ec3_{selected_crop}")
                ec_class4 = st.number_input("Class 4 - Very High (max value)", value=float(crop_values["ec"][3]), key=f"ec4_{selected_crop}")

            with class_col2:
                st.markdown(f"**pH Classification for {selected_crop}**")
                ph_class1 = st.number_input("Class 1 - Acidic (max value)", value=float(crop_values["ph"][0]), key=f"ph1_{selected_crop}")
                ph_class2 = st.number_input("Class 2 - Neutral (max value)", value=float(crop_values["ph"][1]), key=f"ph2_{selected_crop}")
                ph_class3 = st.number_input("Class 3 - Slightly Alkaline (max value)", value=float(crop_values["ph"][2]), key=f"ph3_{selected_crop}")
                ph_class4 = st.number_input("Class 4 - Alkaline (max value)", value=float(crop_values["ph"][3]), key=f"ph4_{selected_crop}")

            current_ec = [ec_class1, ec_class2, ec_class3, ec_class4]
            current_ph = [ph_class1, ph_class2, ph_class3, ph_class4]
            if current_ec != crop_values["ec"] or current_ph != crop_values["ph"]:
                st.session_state.crop_class_values[selected_crop]["ec"] = current_ec
                st.session_state.crop_class_values[selected_crop]["ph"] = current_ph

            ec_labels = crop_values["ec_labels"]
            ph_labels = crop_values["ph_labels"]

            ec_classes = [
                (ec_class1, f"{ec_labels[0]} (< {ec_class1})"),
                (ec_class2, f"{ec_labels[1]} ({ec_class1}-{ec_class2})"),
                (ec_class3, f"{ec_labels[2]} ({ec_class2}-{ec_class3})"),
                (ec_class4, f"{ec_labels[3]} ({ec_class3}-{ec_class4})"),
                (ec_class4 * 2, f"{ec_labels[4]} (> {ec_class4})")
            ]

            ph_classes = [
                (ph_class1, f"{ph_labels[0]} (< {ph_class1})"),
                (ph_class2, f"{ph_labels[1]} ({ph_class1}-{ph_class2})"),
                (ph_class3, f"{ph_labels[2]} ({ph_class2}-{ph_class3})"),
                (ph_class4, f"{ph_labels[3]} ({ph_class3}-{ph_class4})"),
                (14.0, f"{ph_labels[4]} (> {ph_class4})")
            ]

            if st.button(f"Generate EC/pH Maps for {selected_crop}", key="gen_maps", type="primary"):
                if st.session_state.wells_df_raw is not None or st.session_state.ro_df_raw is not None:
                    st.session_state.ec_classes_saved = ec_classes
                    st.session_state.ph_classes_saved = ph_classes
                else:
                    st.warning("Please upload data first.")

            if st.session_state.ec_classes_saved and st.session_state.ph_classes_saved and (st.session_state.wells_df_raw is not None or st.session_state.ro_df_raw is not None):
                wells_df_for_maps = st.session_state.wells_df_raw.copy() if st.session_state.wells_df_raw is not None else None
                ro_df_for_maps = st.session_state.ro_df_raw.copy() if st.session_state.ro_df_raw is not None else None

                if wells_df_for_maps is not None and selected_farms:
                    wells_df_for_maps = wells_df_for_maps[wells_df_for_maps['farm number'].astype(str).isin(selected_farms)]
                    if selected_supplies:
                        wells_df_for_maps = filter_wells_by_supply(wells_df_for_maps, selected_supplies)

                if ro_df_for_maps is not None and selected_farms:
                    ro_df_for_maps = ro_df_for_maps[ro_df_for_maps['farm number'].astype(str).isin(selected_farms)]

                map_col1, map_col2 = st.columns(2)

                with map_col1:
                    st.markdown(f"**EC (Salinity) Distribution - {selected_crop}**")
                    with st.spinner("Generating EC classification map..."):
                        ec_result = create_geopandas_classification_map(wells_df_for_maps, ro_df_for_maps, 'ec', st.session_state.ec_classes_saved)
                        ec_img, ec_diag = ec_result
                        if ec_img:
                            st.image(ec_img, use_container_width=True)
                            with st.expander("Data Summary (EC)", expanded=False):
                                st.write(f"**Wells:** {ec_diag['wells_used']} of {ec_diag['wells_total']} used")
                                st.write(f"- Valid coordinates: {ec_diag['wells_valid_coords']}")
                                st.write(f"- Valid EC values: {ec_diag['wells_valid_values']}")
                                if ec_diag['wells_no_coords']:
                                    st.warning(f"Wells missing coordinates: {len(ec_diag['wells_no_coords'])}")
                                if ec_diag['wells_no_values']:
                                    st.warning(f"Wells missing EC values: {len(ec_diag['wells_no_values'])}")
                        else:
                            failure_reason = ec_diag.get('failure_reason', 'Need at least 3 data points with valid coordinates and EC values.')
                            st.warning(failure_reason)
                            with st.expander("Diagnostic Info (EC)", expanded=True):
                                st.write(f"**Wells:** {ec_diag['wells_total']} total rows")
                                st.write(f"- Valid coordinates: {ec_diag['wells_valid_coords']}")
                                st.write(f"- Valid EC values: {ec_diag['wells_valid_values']}")
                                st.write(f"- Usable for map: {ec_diag['wells_used']}")
                                if ec_diag['wells_no_coords']:
                                    st.error(f"Wells without valid coordinates ({len(ec_diag['wells_no_coords'])}): {', '.join(ec_diag['wells_no_coords'][:10])}{'...' if len(ec_diag['wells_no_coords']) > 10 else ''}")
                                if ec_diag['wells_no_values']:
                                    st.error(f"Wells without EC values ({len(ec_diag['wells_no_values'])}): {', '.join(ec_diag['wells_no_values'][:10])}{'...' if len(ec_diag['wells_no_values']) > 10 else ''}")

                with map_col2:
                    st.markdown(f"**pH Distribution - {selected_crop}**")
                    with st.spinner("Generating pH classification map..."):
                        ph_result = create_geopandas_classification_map(wells_df_for_maps, ro_df_for_maps, 'ph', st.session_state.ph_classes_saved)
                        ph_img, ph_diag = ph_result
                        if ph_img:
                            st.image(ph_img, use_container_width=True)
                            with st.expander("Data Summary (pH)", expanded=False):
                                st.write(f"**Wells:** {ph_diag['wells_used']} of {ph_diag['wells_total']} used")
                                st.write(f"- Valid coordinates: {ph_diag['wells_valid_coords']}")
                                st.write(f"- Valid pH values: {ph_diag['wells_valid_values']}")
                                if ph_diag['wells_no_coords']:
                                    st.warning(f"Wells missing coordinates: {len(ph_diag['wells_no_coords'])}")
                                if ph_diag['wells_no_values']:
                                    st.warning(f"Wells missing pH values: {len(ph_diag['wells_no_values'])}")
                        else:
                            failure_reason = ph_diag.get('failure_reason', 'Need at least 3 data points with valid coordinates and pH values.')
                            st.warning(failure_reason)
                            with st.expander("Diagnostic Info (pH)", expanded=True):
                                st.write(f"**Wells:** {ph_diag['wells_total']} total rows")
                                st.write(f"- Valid coordinates: {ph_diag['wells_valid_coords']}")
                                st.write(f"- Valid pH values: {ph_diag['wells_valid_values']}")
                                st.write(f"- Usable for map: {ph_diag['wells_used']}")
                                if ph_diag['wells_no_coords']:
                                    st.error(f"Wells without valid coordinates ({len(ph_diag['wells_no_coords'])}): {', '.join(ph_diag['wells_no_coords'][:10])}{'...' if len(ph_diag['wells_no_coords']) > 10 else ''}")
                                if ph_diag['wells_no_values']:
                                    st.error(f"Wells without pH values ({len(ph_diag['wells_no_values'])}): {', '.join(ph_diag['wells_no_values'][:10])}{'...' if len(ph_diag['wells_no_values']) > 10 else ''}")

    with tabs[2]:
        st.subheader("Statistical Analysis")

        if status_filter == "Inactive Only":
            st.info("Statistical analysis is not available for inactive units. Please select 'All' or 'Active Only' to view statistics.")
        else:
            col1, col2 = st.columns(2)

            with col1:
                status_fig = create_status_chart(wells_df, ro_df)
                if status_fig:
                    st.plotly_chart(status_fig, use_container_width=True)

            with col2:
                supply_fig = create_supply_chart(wells_df)
                if supply_fig:
                    st.plotly_chart(supply_fig, use_container_width=True)

            col3, col4 = st.columns(2)

            with col3:
                ec_classes_for_stats = st.session_state.get('ec_classes_saved', None)
                salinity_fig = create_salinity_chart(wells_df, ro_df, ec_classes_for_stats)
                if salinity_fig:
                    st.plotly_chart(salinity_fig, use_container_width=True)

            with col4:
                ph_classes_for_stats = st.session_state.get('ph_classes_saved', None)
                ph_fig = create_ph_chart(wells_df, ro_df, ph_classes_for_stats)
                if ph_fig:
                    st.plotly_chart(ph_fig, use_container_width=True)

            st.divider()
            st.subheader("Average Active Units per Farm")
            avg_wells, avg_ro = calculate_avg_active_per_farm(wells_df, ro_df)
            avg_col1, avg_col2 = st.columns(2)
            with avg_col1:
                st.metric("Average Active Wells per Farm", f"{int(round(avg_wells))}")
            with avg_col2:
                st.metric("Average Active RO Units per Farm", f"{int(round(avg_ro))}")

    with tabs[3]:
        st.subheader("Rainfall Events Analysis")
        st.caption("Upload rainfall data to analyze precipitation patterns across farms")

        if 'rainfall_df' not in st.session_state:
            st.session_state.rainfall_df = None
        if 'rainfall_selected_day' not in st.session_state:
            st.session_state.rainfall_selected_day = None
        if 'rainfall_map_buffer' not in st.session_state:
            st.session_state.rainfall_map_buffer = None

        rainfall_file = st.file_uploader(
            "Upload Rainfall Excel File",
            type=['xlsx', 'xls'],
            key="rainfall_uploader",
            help="Excel file with columns: date time, lat, lon, rainfall"
        )

        if rainfall_file:
            try:
                rainfall_raw = pd.read_excel(rainfall_file)
                rainfall_raw.columns = rainfall_raw.columns.str.strip().str.lower()

                required_cols = ['date time', 'lat', 'lon', 'rainfall']
                col_mapping = {}
                for req in required_cols:
                    for col in rainfall_raw.columns:
                        if req.replace(' ', '') in col.replace(' ', '').replace('_', ''):
                            col_mapping[col] = req
                            break

                if len(col_mapping) == len(required_cols):
                    rainfall_raw = rainfall_raw.rename(columns=col_mapping)

                    rainfall_raw['date time'] = pd.to_datetime(rainfall_raw['date time'], errors='coerce')
                    rainfall_raw['lat'] = pd.to_numeric(rainfall_raw['lat'], errors='coerce')
                    rainfall_raw['lon'] = pd.to_numeric(rainfall_raw['lon'], errors='coerce')
                    rainfall_raw['rainfall'] = pd.to_numeric(rainfall_raw['rainfall'], errors='coerce')

                    rainfall_clean = rainfall_raw.dropna(subset=['date time', 'lat', 'lon', 'rainfall'])
                    rainfall_clean['date'] = rainfall_clean['date time'].dt.date

                    st.session_state.rainfall_df = rainfall_clean
                    st.success(f"Loaded {len(rainfall_clean)} rainfall records from {rainfall_clean['date'].nunique()} days")
                else:
                    missing = [r for r in required_cols if r not in col_mapping.values()]
                    st.error(f"Missing required columns: {', '.join(missing)}")
                    st.info("Required columns: date time, lat, lon, rainfall")
            except Exception as e:
                st.error(f"Error reading file: {str(e)}")

        rainfall_df = st.session_state.rainfall_df

        if rainfall_df is not None and len(rainfall_df) > 0:
            st.divider()
            st.markdown("### Rainfall Statistics (Qatar)")

            num_sample_points = rainfall_df.groupby(['lat', 'lon']).ngroups
            num_days = rainfall_df['date'].nunique()

            daily_per_point = rainfall_df.groupby(['lat', 'lon', 'date'])['rainfall'].sum()
            max_daily_rainfall = daily_per_point.max()
            avg_daily_rainfall = daily_per_point.mean()

            stat_col1, stat_col2, stat_col3, stat_col4 = st.columns(4)
            with stat_col1:
                st.metric("Sample Points", num_sample_points)
            with stat_col2:
                st.metric("No. of Days", num_days)
            with stat_col3:
                st.metric("Max Daily Rainfall (mm)", f"{max_daily_rainfall:.1f}")
            with stat_col4:
                st.metric("Avg Daily Rainfall (mm)", f"{avg_daily_rainfall:.2f}")

            farm_locations = {}
            if wells_df is not None and len(wells_df) > 0:
                for _, row in wells_df.iterrows():
                    farm_id = str(row.get('farm number', ''))
                    if farm_id and farm_id != 'nan':
                        lat, lon = parse_coordinates(row.get('well google coordinates', ''))
                        if lat is not None and lon is not None:
                            if farm_id not in farm_locations:
                                farm_locations[farm_id] = {'lats': [], 'lons': []}
                            farm_locations[farm_id]['lats'].append(lat)
                            farm_locations[farm_id]['lons'].append(lon)

            if ro_df is not None and len(ro_df) > 0:
                for _, row in ro_df.iterrows():
                    farm_id = str(row.get('farm number', ''))
                    if farm_id and farm_id != 'nan':
                        lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
                        if lat is not None and lon is not None:
                            if farm_id not in farm_locations:
                                farm_locations[farm_id] = {'lats': [], 'lons': []}
                            farm_locations[farm_id]['lats'].append(lat)
                            farm_locations[farm_id]['lons'].append(lon)

            if farm_locations:
                farm_centroids = {}
                for farm_id, coords_data in farm_locations.items():
                    farm_centroids[farm_id] = {
                        'lat': np.mean(coords_data['lats']),
                        'lon': np.mean(coords_data['lons'])
                    }

                st.session_state.farm_centroids_rainfall = farm_centroids

                st.divider()
                st.markdown("### Farm Rainfall Time Series")

                farm_ids = sorted(farm_centroids.keys())
                selected_farms = st.multiselect(
                    "Select Farms",
                    farm_ids,
                    default=farm_ids[:3] if len(farm_ids) >= 3 else farm_ids,
                    key="rainfall_farm_select"
                )

                if selected_farms:
                    time_series_data = []

                    for _, obs_row in rainfall_df.iterrows():
                        obs_lat = obs_row['lat']
                        obs_lon = obs_row['lon']
                        obs_rainfall = obs_row['rainfall']
                        obs_datetime = obs_row['date time']

                        for farm_id in selected_farms:
                            if farm_id in farm_centroids:
                                centroid = farm_centroids[farm_id]
                                distance = np.sqrt((obs_lon - centroid['lon'])**2 + 
                                                   (obs_lat - centroid['lat'])**2)

                                weight = 1 / (distance + 0.0001)**2

                                time_series_data.append({
                                    'DateTime': obs_datetime,
                                    'Farm': farm_id,
                                    'Rainfall (mm)': obs_rainfall,
                                    'Weight': weight
                                })

                    if time_series_data:
                        ts_df = pd.DataFrame(time_series_data)

                        def weighted_avg(group):
                            return np.sum(group['Rainfall (mm)'] * group['Weight']) / np.sum(group['Weight'])

                        ts_agg = ts_df.groupby(['DateTime', 'Farm']).apply(weighted_avg).reset_index(name='Rainfall (mm)')

                        plt.style.use('seaborn-v0_8-whitegrid')
                        fig, ax = plt.subplots(figsize=(14, 6), dpi=120)

                        colors = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D', '#3B1F2B', 
                                  '#6B4226', '#1B998B', '#FF6B6B', '#4ECDC4', '#45B7D1']

                        for idx, farm_id in enumerate(selected_farms):
                            farm_data = ts_agg[ts_agg['Farm'] == farm_id].sort_values('DateTime')
                            color = colors[idx % len(colors)]
                            ax.plot(farm_data['DateTime'], farm_data['Rainfall (mm)'], 
                                   marker='o', label=f'Farm {farm_id}', linewidth=2.5, 
                                   markersize=6, alpha=0.85, color=color,
                                   markeredgecolor='white', markeredgewidth=0.5)

                        ax.set_xlabel('Date/Time', fontsize=12, fontweight='medium', labelpad=10)
                        ax.set_ylabel('Rainfall (mm)', fontsize=12, fontweight='medium', labelpad=10)
                        ax.set_title('Farm Rainfall Time Series', fontsize=14, fontweight='bold', pad=15)

                        ax.legend(loc='upper right', frameon=True, fancybox=True, 
                                 shadow=True, fontsize=10, framealpha=0.95)

                        ax.grid(True, alpha=0.4, linestyle='--', linewidth=0.7)
                        ax.set_facecolor('#FAFAFA')
                        fig.patch.set_facecolor('white')

                        ax.spines['top'].set_visible(False)
                        ax.spines['right'].set_visible(False)
                        ax.spines['left'].set_linewidth(1.2)
                        ax.spines['bottom'].set_linewidth(1.2)

                        plt.xticks(rotation=45, ha='right', fontsize=10)
                        plt.yticks(fontsize=10)
                        plt.tight_layout()

                        st.pyplot(fig)
                        plt.close(fig)
                        plt.style.use('default')

            st.divider()
            st.markdown("### Daily Rainfall Analysis")

            available_dates = sorted(rainfall_df['date'].unique())
            date_options = [d.strftime('%Y-%m-%d') for d in available_dates]

            selected_date_str = st.selectbox(
                "Select Day",
                date_options,
                key="rainfall_day_select"
            )

            if selected_date_str:
                from datetime import datetime
                selected_date = datetime.strptime(selected_date_str, '%Y-%m-%d').date()
                st.session_state.rainfall_selected_day = selected_date

                day_data = rainfall_df[rainfall_df['date'] == selected_date]
                daily_by_location = day_data.groupby(['lat', 'lon']).agg({'rainfall': 'sum'}).reset_index()

                if len(daily_by_location) >= 3:
                    rainfall_classes = [
                        (5, "Light (< 5 mm)"),
                        (15, "Moderate (5-15 mm)"),
                        (30, "Heavy (15-30 mm)"),
                        (50, "Very Heavy (30-50 mm)"),
                        (200, "Extreme (> 50 mm)")
                    ]

                    current_border = st.session_state.get('custom_border', None)

                    coords = daily_by_location[['lon', 'lat']].values
                    values = daily_by_location['rainfall'].values

                    with st.spinner("Generating rainfall map..."):
                        rainfall_map_buf, diagnostics = create_geopandas_classification_map(
                            None, None, 
                            data_type='rainfall',
                            classes=rainfall_classes,
                            title=f"Rainfall Distribution - {selected_date_str}",
                            unit="Rainfall (mm)",
                            border=current_border,
                            external_data={'coords': coords, 'values': values}
                        )

                    if rainfall_map_buf:
                        st.session_state.rainfall_map_buffer = rainfall_map_buf
                        st.image(rainfall_map_buf, caption=f"Rainfall Distribution - {selected_date_str}", use_container_width=True)
                    else:
                        st.warning("Could not generate rainfall map. Need at least 3 data points within the border.")
                        if diagnostics.get('failure_reason'):
                            st.caption(f"Reason: {diagnostics['failure_reason']}")
                else:
                    st.warning("Need at least 3 rainfall locations to generate interpolated map.")
        else:
            st.info("Upload a rainfall Excel file to begin analysis.")

    with tabs[4]:
        st.subheader("Data Preview")

        if wells_df is not None and len(wells_df) > 0:
            st.markdown("### Wells Data")
            st.dataframe(wells_df, use_container_width=True)

        if ro_df is not None and len(ro_df) > 0:
            st.markdown("### RO Units Data")
            st.dataframe(ro_df, use_container_width=True)

        rainfall_df = st.session_state.get('rainfall_df', None)
        if rainfall_df is not None and len(rainfall_df) > 0:
            st.divider()
            st.markdown("### Farm Rainfall Summary")

            farm_centroids = st.session_state.get('farm_centroids_rainfall', None)

            if farm_centroids is None:
                farm_locations = {}
                if wells_df is not None and len(wells_df) > 0:
                    for _, row in wells_df.iterrows():
                        farm_id = str(row.get('farm number', ''))
                        if farm_id and farm_id != 'nan':
                            lat, lon = parse_coordinates(row.get('well google coordinates', ''))
                            if lat is not None and lon is not None:
                                if farm_id not in farm_locations:
                                    farm_locations[farm_id] = {'lats': [], 'lons': []}
                                farm_locations[farm_id]['lats'].append(lat)
                                farm_locations[farm_id]['lons'].append(lon)

                if ro_df is not None and len(ro_df) > 0:
                    for _, row in ro_df.iterrows():
                        farm_id = str(row.get('farm number', ''))
                        if farm_id and farm_id != 'nan':
                            lat, lon = parse_coordinates(row.get('ro google coordinates', ''))
                            if lat is not None and lon is not None:
                                if farm_id not in farm_locations:
                                    farm_locations[farm_id] = {'lats': [], 'lons': []}
                                farm_locations[farm_id]['lats'].append(lat)
                                farm_locations[farm_id]['lons'].append(lon)

                if farm_locations:
                    farm_centroids = {}
                    for farm_id, coords_data in farm_locations.items():
                        farm_centroids[farm_id] = {
                            'lat': np.mean(coords_data['lats']),
                            'lon': np.mean(coords_data['lons'])
                        }

            if farm_centroids:
                available_dates = sorted(rainfall_df['date'].unique())
                farm_daily_rainfall = []

                for farm_id, centroid in farm_centroids.items():
                    farm_row = {'Farm Number': farm_id}

                    for date in available_dates:
                        day_data = rainfall_df[rainfall_df['date'] == date]
                        daily_by_loc = day_data.groupby(['lat', 'lon']).agg({'rainfall': 'sum'}).reset_index()
                        rain_coords = daily_by_loc[['lon', 'lat']].values
                        rain_values = daily_by_loc['rainfall'].values

                        if len(rain_coords) > 0:
                            distances = np.sqrt((rain_coords[:, 0] - centroid['lon'])**2 + 
                                               (rain_coords[:, 1] - centroid['lat'])**2)

                            if len(distances) >= 3:
                                weights = 1 / (distances + 0.0001)**2
                                interpolated_rainfall = np.sum(weights * rain_values) / np.sum(weights)
                            else:
                                interpolated_rainfall = rain_values[np.argmin(distances)]

                            date_str = date.strftime('%Y-%m-%d')
                            farm_row[date_str] = round(interpolated_rainfall, 2)
                        else:
                            date_str = date.strftime('%Y-%m-%d')
                            farm_row[date_str] = 0.0

                    farm_daily_rainfall.append(farm_row)

                if farm_daily_rainfall:
                    farm_rain_df = pd.DataFrame(farm_daily_rainfall)
                    farm_rain_df = farm_rain_df.sort_values('Farm Number')
                    st.dataframe(farm_rain_df, use_container_width=True, hide_index=True)
            else:
                st.info("Upload wells/RO data to see farm-level rainfall data.")


if __name__ == "__main__":
    main()
